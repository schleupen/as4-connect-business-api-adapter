//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"

namespace BusinessApi
{
	using System = global::System;

	[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class Client
	{
#pragma warning disable 8618 // Set by constructor via BaseUrl property
		private string _baseUrl;
#pragma warning restore 8618 // Set by constructor via BaseUrl property
		private System.Net.Http.HttpClient _httpClient;
		private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);

		public Client(string baseUrl, System.Net.Http.HttpClient httpClient)
		{
			BaseUrl = baseUrl;
			_httpClient = httpClient;
		}

		private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
		{
			var settings = new Newtonsoft.Json.JsonSerializerSettings();
			UpdateJsonSerializerSettings(settings);
			return settings;
		}

		public string BaseUrl
		{
			get { return _baseUrl; }
			set
			{
				_baseUrl = value;
				if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
					_baseUrl += '/';
			}
		}

		protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

		static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

		partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
		partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
		partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

		/// <summary>
		/// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
		/// </summary>
		/// <param name="bDEWDocumentNo">Die Datenaustauschreferenz (DAR).</param>
		/// <param name="bDEWDocType">Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTL, UTILMD ...)</param>
		/// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="direction">Die Richtung der Nachricht.</param>
		/// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
		/// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
		/// <returns>Die Daten der Nachricht.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<MessageQueryResponseDto> V1MpMessagesAsync(string bDEWDocumentNo, string bDEWDocType, string foreignMarketpartner_Id, PartyIdTypeDto? foreignMarketpartner_Type, System.DateTimeOffset? created_at_from, System.DateTimeOffset? created_at_to, MessageDirectionDto? direction, System.Collections.Generic.IEnumerable<OutboundMessageStateDto> outboundState, System.Collections.Generic.IEnumerable<InboundMessageStateDto> inboundState, bool? includeTrace, int? limit)
		{
			return V1MpMessagesAsync(bDEWDocumentNo, bDEWDocType, foreignMarketpartner_Id, foreignMarketpartner_Type, created_at_from, created_at_to, direction, outboundState, inboundState, includeTrace, limit, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
		/// </summary>
		/// <param name="bDEWDocumentNo">Die Datenaustauschreferenz (DAR).</param>
		/// <param name="bDEWDocType">Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTL, UTILMD ...)</param>
		/// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="direction">Die Richtung der Nachricht.</param>
		/// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
		/// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
		/// <returns>Die Daten der Nachricht.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<MessageQueryResponseDto> V1MpMessagesAsync(string bDEWDocumentNo, string bDEWDocType, string foreignMarketpartner_Id, PartyIdTypeDto? foreignMarketpartner_Type, System.DateTimeOffset? created_at_from, System.DateTimeOffset? created_at_to, MessageDirectionDto? direction, System.Collections.Generic.IEnumerable<OutboundMessageStateDto> outboundState, System.Collections.Generic.IEnumerable<InboundMessageStateDto> inboundState, bool? includeTrace, int? limit, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages"
					urlBuilder_.Append("v1/mp/messages");
					urlBuilder_.Append('?');
					if (bDEWDocumentNo != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocumentNo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (bDEWDocType != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (foreignMarketpartner_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (foreignMarketpartner_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (created_at_from != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_from")).Append('=').Append(System.Uri.EscapeDataString(created_at_from.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (created_at_to != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_to")).Append('=').Append(System.Uri.EscapeDataString(created_at_to.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (direction != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Direction")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(direction, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (outboundState != null)
					{
						foreach (var item_ in outboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("OutboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
					}
					if (inboundState != null)
					{
						foreach (var item_ in inboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("InboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
					}
					if (includeTrace != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (limit != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<MessageQueryResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 404)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 403)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Keine Berechtigung Daten \u00fcber diese Nachricht einzusehen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Abfrage von empfangenen Nachrichten.
		/// </summary>
		/// <remarks>
		/// Informationen über empfangenen Nachrichten von fremden Marktpartnern werden hier bereitgestellt.
		/// <br/>Das kontinuierliche Abrufverhalten von neuen Nachrichten sollte von der Geschäftsapplikation wie folgt realisiert werden:
		/// <br/>            
		/// <br/>Die Identifikation von Nachrichten, die noch nicht durch die Geschäfsapplikation verarbeitet wurden, erfolgt über den Endpunkt (`/inbox`). Die Anzahl der Nachrichten die in einem Zyklus abgearbeitet werden sollen kann durch den
		/// <br/>Parameter `limit` spezifiziert werden. Nachrichten die für die Verabeitung in der Geschäftsapplikation bereit sind haben einen der folgenden Zustände:
		/// <br/>* `PROVIDED`: Die Nachricht wurde von AS4 Connect empfangen und bearbeitet. Der Payload wurde noch nicht durch die
		/// <br/>Geschäftsapplikation heruntergeladen. Das Herunterladen der Editfact Dateien erfolgt über `/inbox/payload`. Dabei erfolgt ein Zustandswechsel auf: DELIVERED
		/// <br/>* `DELIVERED`: Der Payload wurde bereits durch die Geschäftsapplikation heruntergeladen aber noch nicht bestätigt. Die heruntergeladene Editfact Datei kann über `/inbox/acknowledgement` bestätigt werden. Der Payload wird aufgrund der variabeln Größe einzeln abgerufen. Dabei erfolgt ein Zustandswechsel auf: auf ACKNOWLEDGED und es werden über (`/inbox`) wieder neuere Nachrichten bereitgestellt.
		/// </remarks>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
		/// <returns>Die eingegangenen Nachrichten.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<QueryInboxMessagesResponseDto> V1MpMessagesInboxAsync(int? limit)
		{
			return V1MpMessagesInboxAsync(limit, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Abfrage von empfangenen Nachrichten.
		/// </summary>
		/// <remarks>
		/// Informationen über empfangenen Nachrichten von fremden Marktpartnern werden hier bereitgestellt.
		/// <br/>Das kontinuierliche Abrufverhalten von neuen Nachrichten sollte von der Geschäftsapplikation wie folgt realisiert werden:
		/// <br/>            
		/// <br/>Die Identifikation von Nachrichten, die noch nicht durch die Geschäfsapplikation verarbeitet wurden, erfolgt über den Endpunkt (`/inbox`). Die Anzahl der Nachrichten die in einem Zyklus abgearbeitet werden sollen kann durch den
		/// <br/>Parameter `limit` spezifiziert werden. Nachrichten die für die Verabeitung in der Geschäftsapplikation bereit sind haben einen der folgenden Zustände:
		/// <br/>* `PROVIDED`: Die Nachricht wurde von AS4 Connect empfangen und bearbeitet. Der Payload wurde noch nicht durch die
		/// <br/>Geschäftsapplikation heruntergeladen. Das Herunterladen der Editfact Dateien erfolgt über `/inbox/payload`. Dabei erfolgt ein Zustandswechsel auf: DELIVERED
		/// <br/>* `DELIVERED`: Der Payload wurde bereits durch die Geschäftsapplikation heruntergeladen aber noch nicht bestätigt. Die heruntergeladene Editfact Datei kann über `/inbox/acknowledgement` bestätigt werden. Der Payload wird aufgrund der variabeln Größe einzeln abgerufen. Dabei erfolgt ein Zustandswechsel auf: auf ACKNOWLEDGED und es werden über (`/inbox`) wieder neuere Nachrichten bereitgestellt.
		/// </remarks>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
		/// <returns>Die eingegangenen Nachrichten.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<QueryInboxMessagesResponseDto> V1MpMessagesInboxAsync(int? limit, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/inbox"
					urlBuilder_.Append("v1/mp/messages/inbox");
					urlBuilder_.Append('?');
					if (limit != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<QueryInboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Limit entspricht nicht den Erwartungen (default: 50, min: 1, max: 1000).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen. Ggf. ein h\u00f6heres Limit verwenden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Abfrage des Payloads (Edifact-Datei) der empfangenen Nachricht.
		/// </summary>
		/// <remarks>
		/// Empfangenen Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Edifact-Datei ist dabei immer
		/// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
		/// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
		/// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
		/// </remarks>
		/// <param name="messageId">Die Id der Nachricht.</param>
		/// <returns>Der Payload der Nachricht.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<FileResponse> V1MpMessagesInboxPayloadAsync(System.Guid messageId)
		{
			return V1MpMessagesInboxPayloadAsync(messageId, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Abfrage des Payloads (Edifact-Datei) der empfangenen Nachricht.
		/// </summary>
		/// <remarks>
		/// Empfangenen Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Edifact-Datei ist dabei immer
		/// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
		/// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
		/// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
		/// </remarks>
		/// <param name="messageId">Die Id der Nachricht.</param>
		/// <returns>Der Payload der Nachricht.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<FileResponse> V1MpMessagesInboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken)
		{
			if (messageId == null)
				throw new System.ArgumentNullException("messageId");

			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/gzip"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/inbox/{messageId}/payload"
					urlBuilder_.Append("v1/mp/messages/inbox/");
					urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
					urlBuilder_.Append("/payload");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200 || status_ == 206)
						{
							var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
							var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
							disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
							return fileResponse_;
						}
						else
						if (status_ == 404)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Nachrichten-Id ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
		/// </summary>
		/// <remarks>
		/// Hier kann der aktuelle Zustand abgefragt werden.
		/// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
		/// <br/>Zustände annehmen:
		/// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
		/// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
		/// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
		/// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
		/// </remarks>
		/// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
		/// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
		/// <param name="state">Filterung nach Status der Nachricht.</param>
		/// <returns>Nachricht wurde erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<GetOutboundMessagesResponseDto> V1MpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid> messageIds, System.Collections.Generic.IEnumerable<string> senderMessageIds, string receiver_Id, PartyIdTypeDto? receiver_Type, System.DateTimeOffset? created_at_from, System.DateTimeOffset? created_at_to, int? limit, System.Collections.Generic.IEnumerable<OutboundMessageStateDto> state)
		{
			return V1MpMessagesOutboxGetAsync(messageIds, senderMessageIds, receiver_Id, receiver_Type, created_at_from, created_at_to, limit, state, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
		/// </summary>
		/// <remarks>
		/// Hier kann der aktuelle Zustand abgefragt werden.
		/// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
		/// <br/>Zustände annehmen:
		/// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
		/// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
		/// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
		/// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
		/// </remarks>
		/// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
		/// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
		/// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
		/// <param name="state">Filterung nach Status der Nachricht.</param>
		/// <returns>Nachricht wurde erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<GetOutboundMessagesResponseDto> V1MpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid> messageIds, System.Collections.Generic.IEnumerable<string> senderMessageIds, string receiver_Id, PartyIdTypeDto? receiver_Type, System.DateTimeOffset? created_at_from, System.DateTimeOffset? created_at_to, int? limit, System.Collections.Generic.IEnumerable<OutboundMessageStateDto> state, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/outbox"
					urlBuilder_.Append("v1/mp/messages/outbox");
					urlBuilder_.Append('?');
					if (messageIds != null)
					{
						foreach (var item_ in messageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("MessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
					}
					if (senderMessageIds != null)
					{
						foreach (var item_ in senderMessageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("SenderMessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
					}
					if (receiver_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (receiver_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (created_at_from != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_from")).Append('=').Append(System.Uri.EscapeDataString(created_at_from.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (created_at_to != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_to")).Append('=').Append(System.Uri.EscapeDataString(created_at_to.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (limit != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (state != null)
					{
						foreach (var item_ in state) { urlBuilder_.Append(System.Uri.EscapeDataString("State")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<GetOutboundMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Nachrichten werden von AS4 Connect asynchron zugestellt.
		/// <br/>Der Status einer Nachricht kann über `GET /outbox` abgefragt werden.
		/// </remarks>
		/// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
		/// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
		/// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
		/// <param name="bDEWDocumentType">Der EDIFACT-Name des Nachrichtentyps gem. UNH DE0065 (z.B. CONTL, UTILMD ...)</param>
		/// <param name="bDEWDocumentNo">Datenaustauschreferenz (DAR) aus UNB DE0020</param>
		/// <param name="bDEWDocumentDate">Datumstempel bei Erzeugung im Format YYYY-MM-DD.</param>
		/// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
		/// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.  
		/// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
		/// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
		/// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
		/// <returns>Nachricht wurde erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<SubmitMessageResponseDto> V1MpMessagesOutboxPostAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, FileParameter payload, string bDEWDocumentType, string bDEWDocumentNo, string bDEWDocumentDate, System.Guid? messageId, string senderMessageId)
		{
			return V1MpMessagesOutboxPostAsync(receiver_Id, receiver_Type, payload, bDEWDocumentType, bDEWDocumentNo, bDEWDocumentDate, messageId, senderMessageId, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Nachrichten werden von AS4 Connect asynchron zugestellt.
		/// <br/>Der Status einer Nachricht kann über `GET /outbox` abgefragt werden.
		/// </remarks>
		/// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
		/// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
		/// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
		/// <param name="bDEWDocumentType">Der EDIFACT-Name des Nachrichtentyps gem. UNH DE0065 (z.B. CONTL, UTILMD ...)</param>
		/// <param name="bDEWDocumentNo">Datenaustauschreferenz (DAR) aus UNB DE0020</param>
		/// <param name="bDEWDocumentDate">Datumstempel bei Erzeugung im Format YYYY-MM-DD.</param>
		/// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
		/// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.  
		/// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
		/// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
		/// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
		/// <returns>Nachricht wurde erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<SubmitMessageResponseDto> V1MpMessagesOutboxPostAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, FileParameter payload, string bDEWDocumentType, string bDEWDocumentNo, string bDEWDocumentDate, System.Guid? messageId, string senderMessageId, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					var boundary_ = System.Guid.NewGuid().ToString();
					var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
					content_.Headers.Remove("Content-Type");
					content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

					if (receiver_Id == null)
						throw new System.ArgumentNullException("receiver_Id");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Id");
					}

					if (receiver_Type == null)
						throw new System.ArgumentNullException("receiver_Type");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Type");
					}

					if (payload == null)
						throw new System.ArgumentNullException("payload");
					else
					{
						var content_payload_ = new System.Net.Http.StreamContent(payload.Data);
						if (!string.IsNullOrEmpty(payload.ContentType))
							content_payload_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(payload.ContentType);
						content_.Add(content_payload_, "Payload", payload.FileName ?? "Payload");
					}

					if (bDEWDocumentType == null)
						throw new System.ArgumentNullException("bDEWDocumentType");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentType, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentType");
					}

					if (bDEWDocumentNo == null)
						throw new System.ArgumentNullException("bDEWDocumentNo");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentNo");
					}

					if (bDEWDocumentDate == null)
						throw new System.ArgumentNullException("bDEWDocumentDate");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentDate, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentDate");
					}

					if (messageId == null)
						throw new System.ArgumentNullException("messageId");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)), "MessageId");
					}

					if (senderMessageId == null)
						throw new System.ArgumentNullException("senderMessageId");
					else
					{
						content_.Add(new System.Net.Http.StringContent(ConvertToString(senderMessageId, System.Globalization.CultureInfo.InvariantCulture)), "SenderMessageId");
					}
					request_.Content = content_;
					request_.Method = new System.Net.Http.HttpMethod("POST");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/outbox"
					urlBuilder_.Append("v1/mp/messages/outbox");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 202)
						{
							var objectResponse_ = await ReadObjectResponseAsync<SubmitMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Fragt die zuletzt empfangenen Nachrichten für den Wechselprozess ab.
		/// </summary>
		/// <remarks>
		/// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten von fremden Marktteilenhmern bereit.
		/// <br/>            
		/// <br/>Eingehende Nachrichten müssen geeignet über die Geschäftsapplikation verarbeitet werden.
		/// <br/>            
		/// <br/>Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
		/// <br/>            
		/// <br/>### PATH_SWITCH_REQUEST ###
		/// <br/>Ein fremder Marktteilnehmer möchte den Übertragungsweg auf AS4 wechseln.
		/// <br/>
		/// <br/>Der fremde Marktpartner kommuniziert (bis zu Bestätigung des Wechsels) weiterhin über den bisherige Übertragungsweg.
		/// <br/>Um dem Wechsel auf AS4 zuzustimmen, muss eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` über `/path-switch/messages/outbox`
		/// <br/>an den fremden Marktteilenhmer gesendet werden.
		/// <br/>            
		/// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// <br/>
		/// <br/>### PATH_SWITCH_CONFIRM ###
		/// <br/>Ein fremder Marktteilnehmer bestätigt den Wechsel auf den AS4-Übertragungsweg.
		/// <br/>            
		/// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// </remarks>
		/// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<QueryPathSwitchInboxMessagesResponseDto> V1PathSwitchMessagesInboxAsync(string sender_Id, PartyIdTypeDto? sender_Type, bool? includeTrace)
		{
			return V1PathSwitchMessagesInboxAsync(sender_Id, sender_Type, includeTrace, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Fragt die zuletzt empfangenen Nachrichten für den Wechselprozess ab.
		/// </summary>
		/// <remarks>
		/// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten von fremden Marktteilenhmern bereit.
		/// <br/>            
		/// <br/>Eingehende Nachrichten müssen geeignet über die Geschäftsapplikation verarbeitet werden.
		/// <br/>            
		/// <br/>Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
		/// <br/>            
		/// <br/>### PATH_SWITCH_REQUEST ###
		/// <br/>Ein fremder Marktteilnehmer möchte den Übertragungsweg auf AS4 wechseln.
		/// <br/>
		/// <br/>Der fremde Marktpartner kommuniziert (bis zu Bestätigung des Wechsels) weiterhin über den bisherige Übertragungsweg.
		/// <br/>Um dem Wechsel auf AS4 zuzustimmen, muss eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` über `/path-switch/messages/outbox`
		/// <br/>an den fremden Marktteilenhmer gesendet werden.
		/// <br/>            
		/// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// <br/>
		/// <br/>### PATH_SWITCH_CONFIRM ###
		/// <br/>Ein fremder Marktteilnehmer bestätigt den Wechsel auf den AS4-Übertragungsweg.
		/// <br/>            
		/// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// </remarks>
		/// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<QueryPathSwitchInboxMessagesResponseDto> V1PathSwitchMessagesInboxAsync(string sender_Id, PartyIdTypeDto? sender_Type, bool? includeTrace, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/path-switch/messages/inbox"
					urlBuilder_.Append("v1/path-switch/messages/inbox");
					urlBuilder_.Append('?');
					if (sender_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (sender_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (includeTrace != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<QueryPathSwitchInboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 404)
						{
							string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("Der Marktteilnehmer ist unbekannt.", status_, responseText_, headers_, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Fragt die zuletzt gesendetet Nachrichten für den Wechselprozess ab.
		/// </summary>
		/// <remarks>
		/// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten die per POST an `/path-switch/messages/outbox`
		/// <br/>gesendet wurden bereit.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand `SUCCESSFUL`.
		/// </remarks>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<QueryPathSwitchOutboxMessagesResponseDto> V1PathSwitchMessagesOutboxGetAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, bool? includeTrace)
		{
			return V1PathSwitchMessagesOutboxGetAsync(receiver_Id, receiver_Type, includeTrace, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Fragt die zuletzt gesendetet Nachrichten für den Wechselprozess ab.
		/// </summary>
		/// <remarks>
		/// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten die per POST an `/path-switch/messages/outbox`
		/// <br/>gesendet wurden bereit.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand `SUCCESSFUL`.
		/// </remarks>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<QueryPathSwitchOutboxMessagesResponseDto> V1PathSwitchMessagesOutboxGetAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, bool? includeTrace, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/path-switch/messages/outbox"
					urlBuilder_.Append("v1/path-switch/messages/outbox");
					urlBuilder_.Append('?');
					if (receiver_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (receiver_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (includeTrace != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<QueryPathSwitchOutboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 404)
						{
							string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("Der Marktteilnehmer ist unbekannt.", status_, responseText_, headers_, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Sendet Nachrichten für den Wechselprozess an Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
		/// <br/>### PATH_SWITCH_REQUEST ###
		/// <br/>Der AS4-Connect Marktpartner möchte den Übertragungsweg auf AS4 ändern und informiert hiermit den fremden
		/// <br/>Marktteilnehmer.
		/// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
		/// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// <br/>Stimmt der fremde Marktteilnehmer dem Wechsel zu, wird er eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` senden.
		/// <br/>Diese kann der AS4-Connect Marktpartner über `/path-switch/messages/inbox` abrufen.
		/// <br/>### PATH_SWITCH_CONFIRM ###
		/// <br/>Der AS4-Connect Marktpartner möchte eine über `/path-switch/messages/inbox` empfangene Wechselanfrage eines fremden
		/// <br/>Marktteilnehmer bestätígen.
		/// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
		/// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// </remarks>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<SubmitPathSwitchMessageResponseDto> V1PathSwitchMessagesOutboxPostAsync(SubmitPathSwitchMessageRequestDto body)
		{
			return V1PathSwitchMessagesOutboxPostAsync(body, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Sendet Nachrichten für den Wechselprozess an Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
		/// <br/>### PATH_SWITCH_REQUEST ###
		/// <br/>Der AS4-Connect Marktpartner möchte den Übertragungsweg auf AS4 ändern und informiert hiermit den fremden
		/// <br/>Marktteilnehmer.
		/// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
		/// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// <br/>Stimmt der fremde Marktteilnehmer dem Wechsel zu, wird er eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` senden.
		/// <br/>Diese kann der AS4-Connect Marktpartner über `/path-switch/messages/inbox` abrufen.
		/// <br/>### PATH_SWITCH_CONFIRM ###
		/// <br/>Der AS4-Connect Marktpartner möchte eine über `/path-switch/messages/inbox` empfangene Wechselanfrage eines fremden
		/// <br/>Marktteilnehmer bestätígen.
		/// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
		/// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
		/// </remarks>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<SubmitPathSwitchMessageResponseDto> V1PathSwitchMessagesOutboxPostAsync(SubmitPathSwitchMessageRequestDto body, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
					var content_ = new System.Net.Http.StringContent(json_);
					content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
					request_.Content = content_;
					request_.Method = new System.Net.Http.HttpMethod("POST");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/path-switch/messages/outbox"
					urlBuilder_.Append("v1/path-switch/messages/outbox");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 202)
						{
							var objectResponse_ = await ReadObjectResponseAsync<SubmitPathSwitchMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 404)
						{
							string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("Der Marktteilnehmer ist unbekannt.", status_, responseText_, headers_, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Fragt die zuletzt empfangenen Test-Nachrichten ab.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich s.g. Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Empfangene Testnachrichten von fremden Marktteilnehmern werden hier bereitgestellt.
		/// <br/>Testnachrichten dienen lediglich zum "Anpingen" von Marktteilnehmern. Der Payload ist hierfür irrelevant und wird
		/// <br/>daher nicht durch AS4 Connect bereitgestellt.
		/// <br/>Details siehe Kapitel 2.3.6 'Testservice' des [BDEW
		/// <br/>AS4-Profil](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AS4%20Profil.pdf)
		/// </remarks>
		/// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<QueryInboxTestMessagesResponseDto> V1TestMessagesInboxAsync(string sender_Id, PartyIdTypeDto? sender_Type, bool? includeTrace)
		{
			return V1TestMessagesInboxAsync(sender_Id, sender_Type, includeTrace, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Fragt die zuletzt empfangenen Test-Nachrichten ab.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich s.g. Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Empfangene Testnachrichten von fremden Marktteilnehmern werden hier bereitgestellt.
		/// <br/>Testnachrichten dienen lediglich zum "Anpingen" von Marktteilnehmern. Der Payload ist hierfür irrelevant und wird
		/// <br/>daher nicht durch AS4 Connect bereitgestellt.
		/// <br/>Details siehe Kapitel 2.3.6 'Testservice' des [BDEW
		/// <br/>AS4-Profil](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AS4%20Profil.pdf)
		/// </remarks>
		/// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<QueryInboxTestMessagesResponseDto> V1TestMessagesInboxAsync(string sender_Id, PartyIdTypeDto? sender_Type, bool? includeTrace, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/test/messages/inbox"
					urlBuilder_.Append("v1/test/messages/inbox");
					urlBuilder_.Append('?');
					if (sender_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (sender_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (includeTrace != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<QueryInboxTestMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Fragt die zuletzt gesendeteten Test-Nachrichten ab.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer feststellen, zu welchem fremden Marktteilenhmer bereits
		/// <br/>Test-Nachrichten gesendet worden sind.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
		/// <br/>`SUCCESSFUL`.
		/// </remarks>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<QueryTestMessageOutboxMessagesResponseDto> V1TestMessagesOutboxGetAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, bool? includeTrace)
		{
			return V1TestMessagesOutboxGetAsync(receiver_Id, receiver_Type, includeTrace, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Fragt die zuletzt gesendeteten Test-Nachrichten ab.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer feststellen, zu welchem fremden Marktteilenhmer bereits
		/// <br/>Test-Nachrichten gesendet worden sind.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
		/// <br/>`SUCCESSFUL`.
		/// </remarks>
		/// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
		/// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
		/// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<QueryTestMessageOutboxMessagesResponseDto> V1TestMessagesOutboxGetAsync(string receiver_Id, PartyIdTypeDto? receiver_Type, bool? includeTrace, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					request_.Method = new System.Net.Http.HttpMethod("GET");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/test/messages/outbox"
					urlBuilder_.Append("v1/test/messages/outbox");
					urlBuilder_.Append('?');
					if (receiver_Id != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (receiver_Type != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					if (includeTrace != null)
					{
						urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
					}
					urlBuilder_.Length--;

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 200)
						{
							var objectResponse_ = await ReadObjectResponseAsync<QueryTestMessageOutboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Sendet Test-Nachrichten an Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer Test-Nachrichten an fremden Marktteilenhmer senden.
		/// <br/>AS4 Connect stellt Test-Nachrichten asynchron zu.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
		/// <br/>`SUCCESSFUL`.
		/// <br/>Der Zustand kann über GET  `/test/messages/outbox/` abgefragt werden.
		/// </remarks>
		/// <param name="body">Die Empänger der Testnachrichten.</param>
		/// <returns>Erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<TestMessageResponseDto> V1TestMessagesOutboxPostAsync(TestMessageRequestDto body)
		{
			return V1TestMessagesOutboxPostAsync(body, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Sendet Test-Nachrichten an Marktteilnehmer.
		/// </summary>
		/// <remarks>
		/// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
		/// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
		/// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer Test-Nachrichten an fremden Marktteilenhmer senden.
		/// <br/>AS4 Connect stellt Test-Nachrichten asynchron zu.
		/// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
		/// <br/>`SUCCESSFUL`.
		/// <br/>Der Zustand kann über GET  `/test/messages/outbox/` abgefragt werden.
		/// </remarks>
		/// <param name="body">Die Empänger der Testnachrichten.</param>
		/// <returns>Erfolgreich empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<TestMessageResponseDto> V1TestMessagesOutboxPostAsync(TestMessageRequestDto body, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
					var content_ = new System.Net.Http.StringContent(json_);
					content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
					request_.Content = content_;
					request_.Method = new System.Net.Http.HttpMethod("POST");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/test/messages/outbox"
					urlBuilder_.Append("v1/test/messages/outbox");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 202)
						{
							var objectResponse_ = await ReadObjectResponseAsync<TestMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Bestätigt den erfolgreichen Erhalt einer Nachricht.
		/// </summary>
		/// <remarks>
		/// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden über `inbox/messages` neuere Nachrichten für die Verarbeitung bereitgestellt.
		/// <br/>
		/// <br/>Um die Authentizität und Integrität der empfangenen Edifact-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
		/// <br/>Der Payload des **JWT** muss den Hashwert der Edifact-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
		/// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
		/// <br/>Verschlüsselt wird das Token nicht.
		/// <br/>            
		/// <br/>**Hinweise**:
		/// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
		/// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
		/// <br/>
		/// <br/>Das Token muss mindestens folgende Claims enthalten:
		/// <br/>```json
		/// <br/>// HEADER:
		/// <br/>{
		/// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
		/// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
		/// <br/>}
		/// <br/>
		/// <br/>// PAYLOAD:
		/// <br/>{
		/// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
		/// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
		/// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
		/// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen") 
		/// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID 
		/// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
		/// <br/>}
		/// <br/>
		/// <br/>// SIGNATURE:
		/// <br/>{
		/// <br/>    ...
		/// <br/>}
		/// <br/>```
		/// </remarks>
		/// <param name="messageId">Die Id der Nachricht.</param>
		/// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
		/// <returns>Bestätigung wurde akzeptiert.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task V1MpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto body)
		{
			return V1MpMessagesInboxAcknowledgementAsync(messageId, body, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Bestätigt den erfolgreichen Erhalt einer Nachricht.
		/// </summary>
		/// <remarks>
		/// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden über `inbox/messages` neuere Nachrichten für die Verarbeitung bereitgestellt.
		/// <br/>
		/// <br/>Um die Authentizität und Integrität der empfangenen Edifact-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
		/// <br/>Der Payload des **JWT** muss den Hashwert der Edifact-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
		/// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
		/// <br/>Verschlüsselt wird das Token nicht.
		/// <br/>            
		/// <br/>**Hinweise**:
		/// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
		/// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
		/// <br/>
		/// <br/>Das Token muss mindestens folgende Claims enthalten:
		/// <br/>```json
		/// <br/>// HEADER:
		/// <br/>{
		/// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
		/// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
		/// <br/>}
		/// <br/>
		/// <br/>// PAYLOAD:
		/// <br/>{
		/// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
		/// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
		/// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
		/// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen") 
		/// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID 
		/// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
		/// <br/>}
		/// <br/>
		/// <br/>// SIGNATURE:
		/// <br/>{
		/// <br/>    ...
		/// <br/>}
		/// <br/>```
		/// </remarks>
		/// <param name="messageId">Die Id der Nachricht.</param>
		/// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
		/// <returns>Bestätigung wurde akzeptiert.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task V1MpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto body, System.Threading.CancellationToken cancellationToken)
		{
			if (messageId == null)
				throw new System.ArgumentNullException("messageId");

			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
					var content_ = new System.Net.Http.StringContent(json_);
					content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
					request_.Content = content_;
					request_.Method = new System.Net.Http.HttpMethod("POST");

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/inbox/{messageId}/acknowledgement"
					urlBuilder_.Append("v1/mp/messages/inbox/");
					urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
					urlBuilder_.Append("/acknowledgement");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 204)
						{
							return;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Best\u00e4tigung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		/// <summary>
		/// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
		/// </summary>
		/// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
		/// <returns>Die erneute Zustellung wurde empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual System.Threading.Tasks.Task<RetryMessagesResponseDto> V1MpMessagesOutboxRetriesAsync(RetryMessagesRequestDto body)
		{
			return V1MpMessagesOutboxRetriesAsync(body, System.Threading.CancellationToken.None);
		}

		/// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
		/// <summary>
		/// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
		/// </summary>
		/// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
		/// <returns>Die erneute Zustellung wurde empfangen.</returns>
		/// <exception cref="ApiException">A server side error occurred.</exception>
		public virtual async System.Threading.Tasks.Task<RetryMessagesResponseDto> V1MpMessagesOutboxRetriesAsync(RetryMessagesRequestDto body, System.Threading.CancellationToken cancellationToken)
		{
			var client_ = _httpClient;
			var disposeClient_ = false;
			try
			{
				using (var request_ = new System.Net.Http.HttpRequestMessage())
				{
					var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
					var content_ = new System.Net.Http.StringContent(json_);
					content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
					request_.Content = content_;
					request_.Method = new System.Net.Http.HttpMethod("POST");
					request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

					var urlBuilder_ = new System.Text.StringBuilder();
					if (!string.IsNullOrEmpty(BaseUrl)) urlBuilder_.Append(BaseUrl);
					// Operation Path: "v1/mp/messages/outbox/retries"
					urlBuilder_.Append("v1/mp/messages/outbox/retries");

					PrepareRequest(client_, request_, urlBuilder_);

					var url_ = urlBuilder_.ToString();
					request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

					PrepareRequest(client_, request_, url_);

					var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
					var disposeResponse_ = true;
					try
					{
						var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
						foreach (var item_ in response_.Headers)
							headers_[item_.Key] = item_.Value;
						if (response_.Content != null && response_.Content.Headers != null)
						{
							foreach (var item_ in response_.Content.Headers)
								headers_[item_.Key] = item_.Value;
						}

						ProcessResponse(client_, response_);

						var status_ = (int)response_.StatusCode;
						if (status_ == 202)
						{
							var objectResponse_ = await ReadObjectResponseAsync<RetryMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							return objectResponse_.Object;
						}
						else
						if (status_ == 400)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Die erneute Zustellung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 404)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Alle angegebenen Nachrichten wurden nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						if (status_ == 429)
						{
							var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
							if (objectResponse_.Object == null)
							{
								throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
							}
							throw new ApiException<ProblemDetails>("Too Many Requests", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
						}
						else
						{
							var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
							throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
						}
					}
					finally
					{
						if (disposeResponse_)
							response_.Dispose();
					}
				}
			}
			finally
			{
				if (disposeClient_)
					client_.Dispose();
			}
		}

		protected struct ObjectResponseResult<T>
		{
			public ObjectResponseResult(T responseObject, string responseText)
			{
				this.Object = responseObject;
				this.Text = responseText;
			}

			public T Object { get; }

			public string Text { get; }
		}

		public bool ReadResponseAsString { get; set; }

		protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
		{
			if (response == null || response.Content == null)
			{
				return new ObjectResponseResult<T>(default(T), string.Empty);
			}

			if (ReadResponseAsString)
			{
				var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
				try
				{
					var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
					return new ObjectResponseResult<T>(typedBody, responseText);
				}
				catch (Newtonsoft.Json.JsonException exception)
				{
					var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
					throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
				}
			}
			else
			{
				try
				{
					using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
					using (var streamReader = new System.IO.StreamReader(responseStream))
					using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
					{
						var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
						var typedBody = serializer.Deserialize<T>(jsonTextReader);
						return new ObjectResponseResult<T>(typedBody, string.Empty);
					}
				}
				catch (Newtonsoft.Json.JsonException exception)
				{
					var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
					throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
				}
			}
		}

		private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
		{
			if (value == null)
			{
				return "";
			}

			if (value is System.Enum)
			{
				var name = System.Enum.GetName(value.GetType(), value);
				if (name != null)
				{
					var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
					if (field != null)
					{
						var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
							as System.Runtime.Serialization.EnumMemberAttribute;
						if (attribute != null)
						{
							return attribute.Value != null ? attribute.Value : name;
						}
					}

					var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
					return converted == null ? string.Empty : converted;
				}
			}
			else if (value is bool)
			{
				return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
			}
			else if (value is byte[])
			{
				return System.Convert.ToBase64String((byte[])value);
			}
			else if (value is string[])
			{
				return string.Join(",", (string[])value);
			}
			else if (value.GetType().IsArray)
			{
				var valueArray = (System.Array)value;
				var valueTextArray = new string[valueArray.Length];
				for (var i = 0; i < valueArray.Length; i++)
				{
					valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
				}
				return string.Join(",", valueTextArray);
			}

			var result = System.Convert.ToString(value, cultureInfo);
			return result == null ? "" : result;
		}
	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class ErrorDto
	{
		/// <summary>
		/// Grundlegende Informationen über den Fehler.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Title { get; set; }

		/// <summary>
		/// Eine detaillierte Beschreibung des Fehlers.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Detail { get; set; }

		/// <summary>
		/// Der Zeitstempel des Fehlers.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.DateTimeOffset Timestamp { get; set; }

		[Newtonsoft.Json.JsonProperty("errorType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public ErrorTypeDto ErrorType { get; set; }

		[Newtonsoft.Json.JsonProperty("responsibleParty", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public ResponsiblePartyDto ResponsibleParty { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum ErrorTypeDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"UNDEFINED")]
		UNDEFINED = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT")]
		TRANSPORT = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"SECURITY")]
		SECURITY = 2,

		[System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL")]
		PROTOCOL = 3,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class GetOutboundMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundMPMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class InboundMPMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public PayloadDto Payload { get; set; }

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public InboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		/// <summary>
		/// Die Datenaustauschreferenz (DAR).
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocumentNo { get; set; }

		/// <summary>
		/// Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTL, UTILMD ...)
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocType { get; set; }

		/// <summary>
		/// Datumstempel bei Erzeugung im Format YYYY-MM-DD.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocumentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocumentDate { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	/// <summary>
	/// Mögliche Status einer eingehenden Nachricht.
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum InboundMessageStateDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
		ACCEPTED = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"PROVIDED")]
		PROVIDED = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"DELIVERED")]
		DELIVERED = 2,

		[System.Runtime.Serialization.EnumMember(Value = @"ACKNOWLEDGED")]
		ACKNOWLEDGED = 3,

		[System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
		FAILED = 4,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class InboundMessageStateDtoMessageTraceEntryDto
	{
		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public InboundMessageStateDto State { get; set; }

		/// <summary>
		/// Zeitstempel der Aktion.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Timestamp { get; set; }

		/// <summary>
		/// Eine optionale Nachricht.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Message { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class InboundPathSwitchMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public InboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public PathSwitchMessageType MessageType { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class InboundTestMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public InboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class MessageAcknowledgedRequestDto
	{
		/// <summary>
		/// Signiertes Json Web Token welches den Hash des empfangenen Payloads beinhaltet.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("jwt", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public string Jwt { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum MessageDirectionDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"INBOUND")]
		INBOUND = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"OUTBOUND")]
		OUTBOUND = 1,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class MessageQueryResponseDto
	{
		[Newtonsoft.Json.JsonProperty("inboundMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundMPMessageDto> InboundMessages { get; set; }

		[Newtonsoft.Json.JsonProperty("outboundMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundMPMessageDto> OutboundMessages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class OutboundMPMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public PayloadDto Payload { get; set; }

		/// <summary>
		/// Die Id der Nachricht die der Sender beim übermitteln der Nachricht vergeben hat.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("senderMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string SenderMessageId { get; set; }

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public OutboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		/// <summary>
		/// Die Datenaustauschreferenz (DAR).
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocumentNo { get; set; }

		/// <summary>
		/// Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTL, UTILMD ...)
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocType { get; set; }

		/// <summary>
		/// Datumstempel bei Erzeugung im Format YYYY-MM-DD.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("bdewDocumentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string BdewDocumentDate { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	/// <summary>
	/// Mögliche Status einer eingehenden Nachricht.
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum OutboundMessageStateDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
		ACCEPTED = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
		IN_PROGRESS = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"SUCCESSFUL")]
		SUCCESSFUL = 2,

		[System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
		FAILED = 3,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class OutboundMessageStateDtoMessageTraceEntryDto
	{
		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public OutboundMessageStateDto State { get; set; }

		/// <summary>
		/// Zeitstempel der Aktion.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Timestamp { get; set; }

		/// <summary>
		/// Eine optionale Nachricht.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Message { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class OutboundPathSwitchMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public OutboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public PathSwitchMessageType MessageType { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class OutboundTestMessageDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.Guid MessageId { get; set; }

		/// <summary>
		/// Der Zeitstempel der Generierung in AS4 Connect.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		public System.DateTimeOffset Created_at { get; set; }

		[Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public PartyInfoDto PartyInfo { get; set; } = new PartyInfoDto();

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public OutboundMessageStateDto State { get; set; }

		[Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto> Trace { get; set; }

		[Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public ErrorDto Error { get; set; }

	}

	/// <summary>
	/// Die codevergebene Stelle der MP-ID.
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum PartyIdTypeDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"BDEW")]
		BDEW = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"DVGW")]
		DVGW = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"GS1")]
		GS1 = 2,

	}

	/// <summary>
	/// Der Identifier eines Marktteilnehmer.
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class PartyIdentifierDto
	{
		/// <summary>
		/// Die Id gemäß Codenummerndatenbank.
		/// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]
		/// </summary>
		[Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public string Id { get; set; }

		[Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public PartyIdTypeDto Type { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class PartyInfoDto
	{
		[Newtonsoft.Json.JsonProperty("sender", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public PartyIdentifierDto Sender { get; set; }

		[Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public PartyIdentifierDto Receiver { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum PathSwitchMessageType
	{

		[System.Runtime.Serialization.EnumMember(Value = @"PATH_SWITCH_REQUEST")]
		PATH_SWITCH_REQUEST = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"PATH_SWITCH_CONFIRM")]
		PATH_SWITCH_CONFIRM = 1,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class PayloadDto
	{
		/// <summary>
		/// Die Größe des komprimierten Payloads in Bytes.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("sizeInBytes", Required = Newtonsoft.Json.Required.Always)]
		public long SizeInBytes { get; set; }

		/// <summary>
		/// Der SHA256 Hash (base64 encoded) des komprimierten Payloads.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("hashSHA256", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public string HashSHA256 { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class ProblemDetails
	{
		[Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Type { get; set; }

		[Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Title { get; set; }

		[Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public int? Status { get; set; }

		[Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Detail { get; set; }

		[Newtonsoft.Json.JsonProperty("instance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public string Instance { get; set; }

		private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

		[Newtonsoft.Json.JsonExtensionData]
		public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
		{
			get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
			set { _additionalProperties = value; }
		}

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class QueryInboxMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundMPMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class QueryInboxTestMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundTestMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class QueryPathSwitchInboxMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<InboundPathSwitchMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class QueryPathSwitchOutboxMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class QueryTestMessageOutboxMessagesResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundTestMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum ResponsiblePartyDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"UNDEFINED")]
		UNDEFINED = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"AS4_CONNECT")]
		AS4_CONNECT = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"FOREIGN_MARKETPARTNER")]
		FOREIGN_MARKETPARTNER = 2,

		[System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER")]
		CUSTOMER = 3,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class RetryMessageRequestDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Guid MessageId { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class RetryMessageResponseDto
	{
		/// <summary>
		/// Die Id der Nachricht
		/// </summary>
		[Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Guid MessageId { get; set; }

		[Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public RetryMessageStateDto State { get; set; }

		/// <summary>
		/// Anzahl der durchgeführten erneuten Zustellungen
		/// </summary>
		[Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public int? Count { get; set; }

	}

	/// <summary>
	/// Mögliche Status einer eingehenden Nachricht.
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public enum RetryMessageStateDto
	{

		[System.Runtime.Serialization.EnumMember(Value = @"RETRY_ACCEPTED")]
		RETRY_ACCEPTED = 0,

		[System.Runtime.Serialization.EnumMember(Value = @"RETRY_MESSAGE_ALREADY_SUCCESSFUL")]
		RETRY_MESSAGE_ALREADY_SUCCESSFUL = 1,

		[System.Runtime.Serialization.EnumMember(Value = @"RETRY_MESSAGE_NOT_FOUND")]
		RETRY_MESSAGE_NOT_FOUND = 2,

		[System.Runtime.Serialization.EnumMember(Value = @"RETRY_LIMIT_REACHED")]
		RETRY_LIMIT_REACHED = 3,

		[System.Runtime.Serialization.EnumMember(Value = @"RETRY_OTHER_ERROR")]
		RETRY_OTHER_ERROR = 4,

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class RetryMessagesRequestDto
	{
		/// <summary>
		/// Erneut zu versendende Nachrichten
		/// </summary>
		[Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public System.Collections.Generic.ICollection<RetryMessageRequestDto> Retries { get; set; } = new System.Collections.ObjectModel.Collection<RetryMessageRequestDto>();

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class RetryMessagesResponseDto
	{
		/// <summary>
		/// Erneut zu versendende Nachrichten
		/// </summary>
		[Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<RetryMessageResponseDto> Retries { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class SubmitMessageResponseDto
	{
		[Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public OutboundMPMessageDto Message { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class SubmitPathSwitchMessageRequestDto
	{
		/// <summary>
		/// Die Empfänger an die eine Path-Switch Message gesendet werden soll.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("receivers", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public System.Collections.Generic.ICollection<PartyIdentifierDto> Receivers { get; set; } = new System.Collections.ObjectModel.Collection<PartyIdentifierDto>();

		[Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
		public PathSwitchMessageType MessageType { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class SubmitPathSwitchMessageResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class TestMessageRequestDto
	{
		/// <summary>
		/// Die Empfänger an die eine Test-Nachricht gesendet werden soll.
		/// </summary>
		[Newtonsoft.Json.JsonProperty("receivers", Required = Newtonsoft.Json.Required.Always)]
		[System.ComponentModel.DataAnnotations.Required]
		public System.Collections.Generic.ICollection<PartyIdentifierDto> Receivers { get; set; } = new System.Collections.ObjectModel.Collection<PartyIdentifierDto>();

	}

	[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class TestMessageResponseDto
	{
		[Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
		public System.Collections.Generic.ICollection<OutboundTestMessageDto> Messages { get; set; }

	}

	[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class FileParameter
	{
		public FileParameter(System.IO.Stream data)
			: this(data, null, null)
		{
		}

		public FileParameter(System.IO.Stream data, string fileName)
			: this(data, fileName, null)
		{
		}

		public FileParameter(System.IO.Stream data, string fileName, string contentType)
		{
			Data = data;
			FileName = fileName;
			ContentType = contentType;
		}

		public System.IO.Stream Data { get; private set; }

		public string FileName { get; private set; }

		public string ContentType { get; private set; }
	}

	[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class FileResponse : System.IDisposable
	{
		private System.IDisposable _client;
		private System.IDisposable _response;

		public int StatusCode { get; private set; }

		public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

		public System.IO.Stream Stream { get; private set; }

		public bool IsPartial
		{
			get { return StatusCode == 206; }
		}

		public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
		{
			StatusCode = statusCode;
			Headers = headers;
			Stream = stream;
			_client = client;
			_response = response;
		}

		public void Dispose()
		{
			Stream.Dispose();
			if (_response != null)
				_response.Dispose();
			if (_client != null)
				_client.Dispose();
		}
	}


	[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class ApiException : System.Exception
	{
		public int StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

		public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
			: base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
		}

		public override string ToString()
		{
			return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
		}
	}

	[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0))")]
	public partial class ApiException<TResult> : ApiException
	{
		public TResult Result { get; private set; }

		public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
			: base(message, statusCode, response, headers, innerException)
		{
			Result = result;
		}
	}

}

#pragma warning restore 108
#pragma warning restore 114
#pragma warning restore 472
#pragma warning restore 612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604