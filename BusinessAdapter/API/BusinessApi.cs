//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#nullable enable

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable CS8765 // Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes).

namespace Schleupen.AS4.BusinessAdapter.API
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IBusinessApiClient
    {

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
        /// </summary>
        /// <param name="bDEWDocType">Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWFulfillmentDate">Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch</param>
        /// <param name="bDEWSubjectPartyId">Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.</param>
        /// <param name="bDEWSubjectPartyRole">Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).</param>
        /// <param name="bDEWDocumentNo">Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="direction">Die Richtung der Nachricht.</param>
        /// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
        /// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
        /// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
        /// <returns>Die Daten der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FPMessageQueryResponseDto> V1FpMessagesAsync(string? bDEWFulfillmentDate = null, string? bDEWSubjectPartyId = null, string? bDEWSubjectPartyRole = null, string? bDEWDocumentNo = null, string? bDEWDocType = null, string? foreignMarketpartner_Id = null, PartyIdTypeDto? foreignMarketpartner_Type = null, System.DateTimeOffset? created_at_from = null, System.DateTimeOffset? created_at_to = null, MessageDirectionDto? direction = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? outboundState = null, System.Collections.Generic.IEnumerable<InboundMessageStateDto>? inboundState = null, bool? includeTrace = null, int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage von empfangenen Nachrichten
        /// </summary>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest, die zurückgegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
        /// <returns>Gibt die empfangenen Nachrichten zurück.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryInboxFPMessagesResponseDto> V1FpMessagesInboxGetAsync(int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InboundFPMessageDto> V1FpMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads (Fahrplan-Datei) für eine eingegangene Nachricht.
        /// </summary>
        /// <remarks>
        /// Empfangene Fahrplan-Dateien können über diesen Endpunkt heruntergeladen werden. Die Fahrplan-Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
        /// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
        /// </remarks>
        /// <param name="messageId">Die GUID der Nachricht.</param>
        /// <returns>Gibt den Payload der Nachricht zurück.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> V1FpMessagesInboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
        /// </summary>
        /// <remarks>
        /// Hier kann der aktuelle Zustand abgefragt werden.
        /// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
        /// <br/>Zustände annehmen:
        /// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
        /// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
        /// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
        /// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
        /// </remarks>
        /// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
        /// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="bDEWFulfillmentDateStart">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="bDEWFulfillmentDateEnd">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
        /// <param name="state">Filterung nach Status der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOutboundFPMessagesResponseDto> V1FpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid>? messageIds = null, System.Collections.Generic.IEnumerable<string>? senderMessageIds = null, string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.DateTimeOffset? bDEWFulfillmentDateStart = null, System.DateTimeOffset? bDEWFulfillmentDateEnd = null, int? limit = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? state = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
        /// </summary>
        /// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
        /// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
        /// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
        /// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
        /// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.
        /// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
        /// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
        /// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
        /// <param name="bDEWDocumentType">Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWDocumentNo">Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWFulfillmentDate">Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch</param>
        /// <param name="bDEWSubjectPartyId">Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.</param>
        /// <param name="bDEWSubjectPartyRole">Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubmitFPMessageResponseDto> V1FpMessagesOutboxPostAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, FileParameter payload = null, string? bDEWDocumentType = null, string? bDEWDocumentNo = null, string? bDEWFulfillmentDate = null, string? bDEWSubjectPartyId = null, string? bDEWSubjectPartyRole = null, System.Guid? messageId = null, string? senderMessageId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
     
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutboundFPMessageDto> V1FpMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
        /// </summary>
        /// <param name="bDEWDocumentNo">Die Datenaustauschreferenz (DAR).</param>
        /// <param name="bDEWDocType">Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)</param>
        /// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="direction">Die Richtung der Nachricht.</param>
        /// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
        /// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
        /// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
        /// <param name="edifactSyntaxCheckStatus">Der Zustand der Edifact-Syntax-Prüfung.</param>
        /// <returns>Die Daten der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MessageQueryResponseDto> V1MpMessagesAsync(string? bDEWDocumentNo = null, string? bDEWDocType = null, string? foreignMarketpartner_Id = null, PartyIdTypeDto? foreignMarketpartner_Type = null, System.DateTimeOffset? created_at_from = null, System.DateTimeOffset? created_at_to = null, MessageDirectionDto? direction = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? outboundState = null, System.Collections.Generic.IEnumerable<InboundMessageStateDto>? inboundState = null, bool? includeTrace = null, int? limit = null, EdifactSyntaxCheckStatusDto? edifactSyntaxCheckStatus = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage von empfangenen Nachrichten.
        /// </summary>
        /// <remarks>
        /// Informationen über empfangenen Nachrichten von fremden Marktpartnern werden hier bereitgestellt.
        /// <br/>Das kontinuierliche Abrufverhalten von neuen Nachrichten sollte von der Geschäftsapplikation wie folgt realisiert werden:
        /// <br/>            
        /// <br/>Die Identifikation von Nachrichten, die noch nicht durch die Geschäfsapplikation verarbeitet wurden, erfolgt über den Endpunkt (`/inbox`). Die Anzahl der Nachrichten die in einem Zyklus abgearbeitet werden sollen kann durch den
        /// <br/>Parameter `limit` spezifiziert werden. Nachrichten die für die Verabeitung in der Geschäftsapplikation bereit sind haben einen der folgenden Zustände:
        /// <br/>* `PROVIDED`: Die Nachricht wurde von AS4 Connect empfangen und bearbeitet. Der Payload wurde noch nicht durch die
        /// <br/>Geschäftsapplikation heruntergeladen. Das Herunterladen der Editfact Dateien erfolgt über `/inbox/payload`. Dabei erfolgt ein Zustandswechsel auf: DELIVERED
        /// <br/>* `DELIVERED`: Der Payload wurde bereits durch die Geschäftsapplikation heruntergeladen aber noch nicht bestätigt. Die heruntergeladene Editfact Datei kann über `/inbox/acknowledgement` bestätigt werden. Der Payload wird aufgrund der variabeln Größe einzeln abgerufen. Dabei erfolgt ein Zustandswechsel auf: auf ACKNOWLEDGED und es werden über (`/inbox`) wieder neuere Nachrichten bereitgestellt.
        /// </remarks>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest, die zurückgegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
        /// <returns>Die eingegangenen Nachrichten.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryInboxMessagesResponseDto> V1MpMessagesInboxGetAsync(int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InboundMPMessageDto> V1MpMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads (Edifact-Datei) der empfangenen Nachricht.
        /// </summary>
        /// <remarks>
        /// Empfangene Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Edifact-Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
        /// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Der Payload der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> V1MpMessagesInboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
        /// </summary>
        /// <remarks>
        /// Hier kann der aktuelle Zustand abgefragt werden.
        /// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
        /// <br/>Zustände annehmen:
        /// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
        /// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
        /// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
        /// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
        /// </remarks>
        /// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
        /// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="bDEWFulfillmentDateStart">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="bDEWFulfillmentDateEnd">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
        /// <param name="state">Filterung nach Status der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetOutboundMessagesResponseDto> V1MpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid>? messageIds = null, System.Collections.Generic.IEnumerable<string>? senderMessageIds = null, string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.DateTimeOffset? bDEWFulfillmentDateStart = null, System.DateTimeOffset? bDEWFulfillmentDateEnd = null, int? limit = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? state = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Nachrichten werden von AS4 Connect asynchron zugestellt.
        /// <br/>Der Status einer Nachricht kann über `GET /outbox` abgefragt werden.
        /// </remarks>
        /// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
        /// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
        /// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
        /// <param name="bDEWDocumentType">Der EDIFACT-Name des Nachrichtentyps gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)</param>
        /// <param name="bDEWDocumentNo">Datenaustauschreferenz (DAR) aus UNB DE0020</param>
        /// <param name="bDEWDocumentDate">Datumstempel bei Erzeugung im Format YYYY-MM-DD.</param>
        /// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
        /// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.
        /// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
        /// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
        /// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubmitMessageResponseDto> V1MpMessagesOutboxPostAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, FileParameter payload = null, string? bDEWDocumentType = null, string? bDEWDocumentNo = null, string? bDEWDocumentDate = null, System.Guid? messageId = null, string? senderMessageId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutboundMPMessageDto> V1MpMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads der ausgehenden Nachricht.
        /// </summary>
        /// <remarks>
        /// Ausgehende Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Der Payload der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> V1MpMessagesOutboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt empfangenen Nachrichten für den Wechselprozess ab.
        /// </summary>
        /// <remarks>
        /// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten von fremden Marktteilenhmern bereit.
        /// <br/>            
        /// <br/>Eingehende Nachrichten müssen geeignet über die Geschäftsapplikation verarbeitet werden.
        /// <br/>            
        /// <br/>Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
        /// <br/>            
        /// <br/>### PATH_SWITCH_REQUEST ###
        /// <br/>Ein fremder Marktteilnehmer möchte den Übertragungsweg auf AS4 wechseln.
        /// <br/>            
        /// <br/>Der fremde Marktpartner kommuniziert (bis zu Bestätigung des Wechsels) weiterhin über den bisherige Übertragungsweg.
        /// <br/>Um dem Wechsel auf AS4 zuzustimmen, muss eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` über `/path-switch/messages/outbox`
        /// <br/>an den fremden Marktteilenhmer gesendet werden.
        /// <br/>            
        /// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// <br/>            
        /// <br/>### PATH_SWITCH_CONFIRM ###
        /// <br/>Ein fremder Marktteilnehmer bestätigt den Wechsel auf den AS4-Übertragungsweg.
        /// <br/>            
        /// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// </remarks>
        /// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryPathSwitchInboxMessagesResponseDto> V1PathSwitchMessagesInboxGetAsync(string? sender_Id = null, PartyIdTypeDto? sender_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InboundPathSwitchMessageDto> V1PathSwitchMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt gesendetet Nachrichten für den Wechselprozess ab.
        /// </summary>
        /// <remarks>
        /// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten die per POST an `/path-switch/messages/outbox`
        /// <br/>gesendet wurden bereit.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand `SUCCESSFUL`.
        /// </remarks>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryPathSwitchOutboxMessagesResponseDto> V1PathSwitchMessagesOutboxGetAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sendet Nachrichten für den Wechselprozess an Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
        /// <br/>### PATH_SWITCH_REQUEST ###
        /// <br/>Der AS4-Connect Marktpartner möchte den Übertragungsweg auf AS4 ändern und informiert hiermit den fremden
        /// <br/>Marktteilnehmer.
        /// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
        /// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// <br/>Stimmt der fremde Marktteilnehmer dem Wechsel zu, wird er eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` senden.
        /// <br/>Diese kann der AS4-Connect Marktpartner über `/path-switch/messages/inbox` abrufen.
        /// <br/>### PATH_SWITCH_CONFIRM ###
        /// <br/>Der AS4-Connect Marktpartner möchte eine über `/path-switch/messages/inbox` empfangene Wechselanfrage eines fremden
        /// <br/>Marktteilnehmer bestätígen.
        /// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
        /// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// </remarks>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SubmitPathSwitchMessageResponseDto> V1PathSwitchMessagesOutboxPostAsync(SubmitPathSwitchMessageRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutboundPathSwitchMessageDto> V1PathSwitchMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gibt Statistiken über die Anzahl der ein- und ausgehenden Nachrichten für einen Marktpartner im letzten und im laufenden Monat zurück.
        /// </summary>
        /// <returns>Die Statistik für den Marktpartner.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<StatisticsResponseDto> V1StatisticsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt empfangenen Test-Nachrichten ab.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich s.g. Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Empfangene Testnachrichten von fremden Marktteilnehmern werden hier bereitgestellt.
        /// <br/>Testnachrichten dienen lediglich zum "Anpingen" von Marktteilnehmern. Der Payload ist hierfür irrelevant und wird
        /// <br/>daher nicht durch AS4 Connect bereitgestellt.
        /// <br/>Details siehe Kapitel 2.3.6 'Testservice' des [BDEW
        /// <br/>AS4-Profil](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AS4%20Profil.pdf)
        /// </remarks>
        /// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryInboxTestMessagesResponseDto> V1TestMessagesInboxGetAsync(string? sender_Id = null, PartyIdTypeDto? sender_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InboundTestMessageDto> V1TestMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt gesendeteten Test-Nachrichten ab.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer feststellen, zu welchem fremden Marktteilenhmer bereits
        /// <br/>Test-Nachrichten gesendet worden sind.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
        /// <br/>`SUCCESSFUL`.
        /// </remarks>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<QueryTestMessageOutboxMessagesResponseDto> V1TestMessagesOutboxGetAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sendet Test-Nachrichten an Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer Test-Nachrichten an fremden Marktteilenhmer senden.
        /// <br/>AS4 Connect stellt Test-Nachrichten asynchron zu.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
        /// <br/>`SUCCESSFUL`.
        /// <br/>Der Zustand kann über GET  `/test/messages/outbox/` abgefragt werden.
        /// </remarks>
        /// <param name="body">Die Empänger der Testnachrichten.</param>
        /// <returns>Erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TestMessageResponseDto> V1TestMessagesOutboxPostAsync(TestMessageRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OutboundTestMessageDto> V1TestMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bestätigt den erfolgreichen Erhalt einer Nachricht.
        /// </summary>
        /// <remarks>
        /// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden neuere Nachrichten für die Verarbeitung bereitgestellt.
        /// <br/>            
        /// <br/>Um die Authentizität und Integrität der empfangenen Fahrplan-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
        /// <br/>Der Payload des **JWT** muss den Hashwert der Fahrplan-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
        /// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
        /// <br/>Verschlüsselt wird das Token nicht.
        /// <br/>            
        /// <br/>**Hinweise**:
        /// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
        /// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
        /// <br/>            
        /// <br/>Das Token muss mindestens folgende Claims enthalten:
        /// <br/>```json
        /// <br/>// HEADER:
        /// <br/>{
        /// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
        /// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
        /// <br/>}
        /// <br/>            
        /// <br/>// PAYLOAD:
        /// <br/>{
        /// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
        /// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
        /// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
        /// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen")
        /// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID
        /// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
        /// <br/>}
        /// <br/>            
        /// <br/>// SIGNATURE:
        /// <br/>{
        /// <br/>    ...
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
        /// <returns>Bestätigung wurde akzeptiert.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task V1FpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
        /// </summary>
        /// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
        /// <returns>Die erneute Zustellung wurde empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RetryMessagesResponseDto> V1FpMessagesOutboxRetriesAsync(RetryMessagesRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bestätigt den erfolgreichen Erhalt einer Nachricht.
        /// </summary>
        /// <remarks>
        /// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden über `inbox/messages` neuere Nachrichten für die Verarbeitung bereitgestellt.
        /// <br/>            
        /// <br/>Um die Authentizität und Integrität der empfangenen Edifact-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
        /// <br/>Der Payload des **JWT** muss den Hashwert der Edifact-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
        /// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
        /// <br/>Verschlüsselt wird das Token nicht.
        /// <br/>            
        /// <br/>**Hinweise**:
        /// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
        /// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
        /// <br/>            
        /// <br/>Das Token muss mindestens folgende Claims enthalten:
        /// <br/>```json
        /// <br/>// HEADER:
        /// <br/>{
        /// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
        /// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
        /// <br/>}
        /// <br/>            
        /// <br/>// PAYLOAD:
        /// <br/>{
        /// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
        /// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
        /// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
        /// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen")
        /// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID
        /// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
        /// <br/>}
        /// <br/>            
        /// <br/>// SIGNATURE:
        /// <br/>{
        /// <br/>    ...
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
        /// <returns>Bestätigung wurde akzeptiert.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task V1MpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
        /// </summary>
        /// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
        /// <returns>Die erneute Zustellung wurde empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RetryMessagesResponseDto> V1MpMessagesOutboxRetriesAsync(RetryMessagesRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BusinessApiClient : IBusinessApiClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings, true);

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public BusinessApiClient(string baseUrl, System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = baseUrl;
            _httpClient = httpClient;
        }

        private static Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
        /// </summary>
        /// <param name="bDEWDocType">Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWFulfillmentDate">Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch</param>
        /// <param name="bDEWSubjectPartyId">Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.</param>
        /// <param name="bDEWSubjectPartyRole">Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).</param>
        /// <param name="bDEWDocumentNo">Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="direction">Die Richtung der Nachricht.</param>
        /// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
        /// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
        /// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
        /// <returns>Die Daten der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FPMessageQueryResponseDto> V1FpMessagesAsync(string? bDEWDocType = null, string? bDEWFulfillmentDate = null, string? bDEWSubjectPartyId = null, string? bDEWSubjectPartyRole = null, string? bDEWDocumentNo = null, string? foreignMarketpartner_Id = null, PartyIdTypeDto? foreignMarketpartner_Type = null, System.DateTimeOffset? created_at_from = null, System.DateTimeOffset? created_at_to = null, MessageDirectionDto? direction = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? outboundState = null, System.Collections.Generic.IEnumerable<InboundMessageStateDto>? inboundState = null, bool? includeTrace = null, int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages"
                    urlBuilder_.Append("v1/fp/messages");
                    urlBuilder_.Append('?');
                    if (bDEWDocType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWFulfillmentDate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWFulfillmentDate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWFulfillmentDate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWSubjectPartyId != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWSubjectPartyId")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWSubjectPartyId, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWSubjectPartyRole != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWSubjectPartyRole")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWSubjectPartyRole, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWDocumentNo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocumentNo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (foreignMarketpartner_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (foreignMarketpartner_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_from")).Append('=').Append(System.Uri.EscapeDataString(created_at_from.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_to")).Append('=').Append(System.Uri.EscapeDataString(created_at_to.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (direction != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Direction")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(direction, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (outboundState != null)
                    {
                        foreach (var item_ in outboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("OutboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (inboundState != null)
                    {
                        foreach (var item_ in inboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("InboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (includeTrace != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FPMessageQueryResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Keine Berechtigung Daten \u00fcber diese Nachricht einzusehen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage von empfangenen Nachrichten
        /// </summary>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest, die zurückgegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
        /// <returns>Gibt die empfangenen Nachrichten zurück.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryInboxFPMessagesResponseDto> V1FpMessagesInboxGetAsync(int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/inbox"
                    urlBuilder_.Append("v1/fp/messages/inbox");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryInboxFPMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Limit entspricht nicht den Erwartungen (default: 50, min: 1, max: 1000) oder bei der Authentifikation trat ein Fehler auf.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen. Ggf. ein h\u00f6heres Limit verwenden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InboundFPMessageDto> V1FpMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/inbox/{messageId}"
                    urlBuilder_.Append("v1/fp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InboundFPMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads (Fahrplan-Datei) für eine eingegangene Nachricht.
        /// </summary>
        /// <remarks>
        /// Empfangene Fahrplan-Dateien können über diesen Endpunkt heruntergeladen werden. Die Fahrplan-Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
        /// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
        /// </remarks>
        /// <param name="messageId">Die GUID der Nachricht.</param>
        /// <returns>Gibt den Payload der Nachricht zurück.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> V1FpMessagesInboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/gzip"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/inbox/{messageId}/payload"
                    urlBuilder_.Append("v1/fp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/payload");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("F\u00fcr den Nutzer liegt keine Nachricht mit der angegebenen Id vor oder der Payload konnte nicht heruntergeladen werden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
        /// </summary>
        /// <remarks>
        /// Hier kann der aktuelle Zustand abgefragt werden.
        /// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
        /// <br/>Zustände annehmen:
        /// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
        /// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
        /// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
        /// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
        /// </remarks>
        /// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
        /// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="bDEWFulfillmentDateStart">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="bDEWFulfillmentDateEnd">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
        /// <param name="state">Filterung nach Status der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetOutboundFPMessagesResponseDto> V1FpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid>? messageIds = null, System.Collections.Generic.IEnumerable<string>? senderMessageIds = null, string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.DateTimeOffset? bDEWFulfillmentDateStart = null, System.DateTimeOffset? bDEWFulfillmentDateEnd = null, int? limit = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? state = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/outbox"
                    urlBuilder_.Append("v1/fp/messages/outbox");
                    urlBuilder_.Append('?');
                    if (messageIds != null)
                    {
                        foreach (var item_ in messageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("MessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (senderMessageIds != null)
                    {
                        foreach (var item_ in senderMessageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("SenderMessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (receiver_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (receiver_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWFulfillmentDateStart != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWFulfillmentDateStart")).Append('=').Append(System.Uri.EscapeDataString(bDEWFulfillmentDateStart.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWFulfillmentDateEnd != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWFulfillmentDateEnd")).Append('=').Append(System.Uri.EscapeDataString(bDEWFulfillmentDateEnd.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (state != null)
                    {
                        foreach (var item_ in state) { urlBuilder_.Append(System.Uri.EscapeDataString("State")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetOutboundFPMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
        /// </summary>
        /// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
        /// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
        /// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
        /// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
        /// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.
        /// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
        /// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
        /// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
        /// <param name="bDEWDocumentType">Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWDocumentNo">Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1</param>
        /// <param name="bDEWFulfillmentDate">Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch</param>
        /// <param name="bDEWSubjectPartyId">Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.</param>
        /// <param name="bDEWSubjectPartyRole">Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubmitFPMessageResponseDto> V1FpMessagesOutboxPostAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, FileParameter payload = null, System.Guid? messageId = null, string? senderMessageId = null, string? bDEWDocumentType = null, string? bDEWDocumentNo = null, string? bDEWFulfillmentDate = null, string? bDEWSubjectPartyId = null, string? bDEWSubjectPartyRole = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

                    if (receiver_Id == null)
                        throw new System.ArgumentNullException("receiver_Id");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Id");
                    }

                    if (receiver_Type == null)
                        throw new System.ArgumentNullException("receiver_Type");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Type");
                    }

                    if (payload == null)
                        throw new System.ArgumentNullException("payload");
                    else
                    {
                        var content_payload_ = new System.Net.Http.StreamContent(payload.Data);
                        if (!string.IsNullOrEmpty(payload.ContentType))
                            content_payload_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(payload.ContentType);
                        content_.Add(content_payload_, "Payload", payload.FileName ?? "Payload");
                    }

                    if (messageId == null)
                        throw new System.ArgumentNullException("messageId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)), "MessageId");
                    }

                    if (senderMessageId == null)
                        throw new System.ArgumentNullException("senderMessageId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(senderMessageId, System.Globalization.CultureInfo.InvariantCulture)), "SenderMessageId");
                    }

                    if (bDEWDocumentType == null)
                        throw new System.ArgumentNullException("bDEWDocumentType");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentType, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentType");
                    }

                    if (bDEWDocumentNo == null)
                        throw new System.ArgumentNullException("bDEWDocumentNo");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentNo");
                    }

                    if (bDEWFulfillmentDate == null)
                        throw new System.ArgumentNullException("bDEWFulfillmentDate");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWFulfillmentDate, System.Globalization.CultureInfo.InvariantCulture)), "BDEWFulfillmentDate");
                    }

                    if (bDEWSubjectPartyId == null)
                        throw new System.ArgumentNullException("bDEWSubjectPartyId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWSubjectPartyId, System.Globalization.CultureInfo.InvariantCulture)), "BDEWSubjectPartyId");
                    }

                    if (bDEWSubjectPartyRole == null)
                        throw new System.ArgumentNullException("bDEWSubjectPartyRole");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWSubjectPartyRole, System.Globalization.CultureInfo.InvariantCulture)), "BDEWSubjectPartyRole");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/outbox"
                    urlBuilder_.Append("v1/fp/messages/outbox");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubmitFPMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OutboundFPMessageDto> V1FpMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/outbox/{messageId}"
                    urlBuilder_.Append("v1/fp/messages/outbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OutboundFPMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bietet Abfragemöglichkeiten für eingehende und ausgehende Nachrichten.
        /// </summary>
        /// <param name="bDEWDocumentNo">Die Datenaustauschreferenz (DAR).</param>
        /// <param name="bDEWDocType">Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)</param>
        /// <param name="foreignMarketpartner_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="foreignMarketpartner_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="created_at_from">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="created_at_to">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="direction">Die Richtung der Nachricht.</param>
        /// <param name="outboundState">Die Zustände für ausgehende Nachrichten.</param>
        /// <param name="inboundState">Die Zustände für eingehende Nachrichten.</param>
        /// <param name="includeTrace">Bestimmt ob die Historie der Nachricht mit übertragen werden soll.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen pro Richtung (Inbox/Outbox). (default: 50, min: 1)</param>
        /// <param name="edifactSyntaxCheckStatus">Der Zustand der Edifact-Syntax-Prüfung.</param>
        /// <returns>Die Daten der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<MessageQueryResponseDto> V1MpMessagesAsync(string? bDEWDocumentNo = null, string? bDEWDocType = null, string? foreignMarketpartner_Id = null, PartyIdTypeDto? foreignMarketpartner_Type = null, System.DateTimeOffset? created_at_from = null, System.DateTimeOffset? created_at_to = null, MessageDirectionDto? direction = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? outboundState = null, System.Collections.Generic.IEnumerable<InboundMessageStateDto>? inboundState = null, bool? includeTrace = null, int? limit = null, EdifactSyntaxCheckStatusDto? edifactSyntaxCheckStatus = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages"
                    urlBuilder_.Append("v1/mp/messages");
                    urlBuilder_.Append('?');
                    if (bDEWDocumentNo != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocumentNo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWDocType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWDocType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bDEWDocType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (foreignMarketpartner_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (foreignMarketpartner_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("ForeignMarketpartner.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(foreignMarketpartner_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_from")).Append('=').Append(System.Uri.EscapeDataString(created_at_from.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Created_at_to")).Append('=').Append(System.Uri.EscapeDataString(created_at_to.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (direction != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Direction")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(direction, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (outboundState != null)
                    {
                        foreach (var item_ in outboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("OutboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (inboundState != null)
                    {
                        foreach (var item_ in inboundState) { urlBuilder_.Append(System.Uri.EscapeDataString("InboundState")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (includeTrace != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("IncludeTrace")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(includeTrace, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (edifactSyntaxCheckStatus != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("EdifactSyntaxCheckStatus")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(edifactSyntaxCheckStatus, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<MessageQueryResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Keine Berechtigung Daten \u00fcber diese Nachricht einzusehen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage von empfangenen Nachrichten.
        /// </summary>
        /// <remarks>
        /// Informationen über empfangenen Nachrichten von fremden Marktpartnern werden hier bereitgestellt.
        /// <br/>Das kontinuierliche Abrufverhalten von neuen Nachrichten sollte von der Geschäftsapplikation wie folgt realisiert werden:
        /// <br/>            
        /// <br/>Die Identifikation von Nachrichten, die noch nicht durch die Geschäfsapplikation verarbeitet wurden, erfolgt über den Endpunkt (`/inbox`). Die Anzahl der Nachrichten die in einem Zyklus abgearbeitet werden sollen kann durch den
        /// <br/>Parameter `limit` spezifiziert werden. Nachrichten die für die Verabeitung in der Geschäftsapplikation bereit sind haben einen der folgenden Zustände:
        /// <br/>* `PROVIDED`: Die Nachricht wurde von AS4 Connect empfangen und bearbeitet. Der Payload wurde noch nicht durch die
        /// <br/>Geschäftsapplikation heruntergeladen. Das Herunterladen der Editfact Dateien erfolgt über `/inbox/payload`. Dabei erfolgt ein Zustandswechsel auf: DELIVERED
        /// <br/>* `DELIVERED`: Der Payload wurde bereits durch die Geschäftsapplikation heruntergeladen aber noch nicht bestätigt. Die heruntergeladene Editfact Datei kann über `/inbox/acknowledgement` bestätigt werden. Der Payload wird aufgrund der variabeln Größe einzeln abgerufen. Dabei erfolgt ein Zustandswechsel auf: auf ACKNOWLEDGED und es werden über (`/inbox`) wieder neuere Nachrichten bereitgestellt.
        /// </remarks>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest, die zurückgegeben werden sollen. (default: 50, min: 1, max: 1000)</param>
        /// <returns>Die eingegangenen Nachrichten.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryInboxMessagesResponseDto> V1MpMessagesInboxGetAsync(int? limit = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/inbox"
                    urlBuilder_.Append("v1/mp/messages/inbox");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryInboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Limit entspricht nicht den Erwartungen (default: 50, min: 1, max: 1000).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen. Ggf. ein h\u00f6heres Limit verwenden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InboundMPMessageDto> V1MpMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/inbox/{messageId}"
                    urlBuilder_.Append("v1/mp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InboundMPMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads (Edifact-Datei) der empfangenen Nachricht.
        /// </summary>
        /// <remarks>
        /// Empfangene Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Edifact-Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// <br/>Nach dem Download befinden sich die zugehörige Nachrichten in dem Zustand `PAYLOAD_DELIVERED` und müssen im
        /// <br/>weiteren Verlauf über `/acknowledgement` bestätigt werden (Zustandswechsel auf `ACKNOWLEDGED`).
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Der Payload der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> V1MpMessagesInboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/gzip"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/inbox/{messageId}/payload"
                    urlBuilder_.Append("v1/mp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/payload");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachrichten-Id ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt ausgehende Nachrichten (insb. den Zustand) ab.
        /// </summary>
        /// <remarks>
        /// Hier kann der aktuelle Zustand abgefragt werden.
        /// <br/>Nachrichten werden von AS4 Connect asynchron verarbeitet. Eine ausgehende Nachricht kann dabei die folgenden
        /// <br/>Zustände annehmen:
        /// <br/>* `ACCEPTED`: Die Nachricht der Geschäftsapplikation wurde von AS4 Connect angenommen und wird zeitnah verarbeitet.
        /// <br/>* `IN_PROGRESS`: Die Nachricht befindet aktuell in Verarbeitung und wird zeitnah an den fremdnen Marktpartner gesendet.
        /// <br/>* `SUCCESSFUL`: Die Nachricht wurde von AS4 Connect erfolreich an den fremden Marktpartner gesendet. Der fremden Marktpartner hat für die Nachricht eine valide Quittung (Receipt) erzeugt.
        /// <br/>* `FAILED`: Die Nachricht wird aufgrund von Fehlern nicht weiter verarbeitet. Weitere Informationen sind als 'Error' hinterlegt. Soll die Nachricht weiterhin an den fremden Martpartner gesendet werden, muss die Geschäftsapplikation die Nachricht erneut an AS4 Connect senden.
        /// </remarks>
        /// <param name="messageIds">Filterung nach MessageIds die von AS4 Connect vergeben wurden.</param>
        /// <param name="senderMessageIds">Filterung nach MessageIds die von der Geschäftsapplikation beim Senden mit angegeben wurden (s. `SenderMessageId`).</param>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <param name="bDEWFulfillmentDateStart">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="bDEWFulfillmentDateEnd">Schränkt die Ergebnismenge bzgl. des Erstellzeitpunkts ein.</param>
        /// <param name="limit">Legt die Anzahl der Nachrichten fest die zurück gegeben werden sollen. (default: 50, min: 1)</param>
        /// <param name="state">Filterung nach Status der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetOutboundMessagesResponseDto> V1MpMessagesOutboxGetAsync(System.Collections.Generic.IEnumerable<System.Guid>? messageIds = null, System.Collections.Generic.IEnumerable<string>? senderMessageIds = null, string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.DateTimeOffset? bDEWFulfillmentDateStart = null, System.DateTimeOffset? bDEWFulfillmentDateEnd = null, int? limit = null, System.Collections.Generic.IEnumerable<OutboundMessageStateDto>? state = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/outbox"
                    urlBuilder_.Append("v1/mp/messages/outbox");
                    urlBuilder_.Append('?');
                    if (messageIds != null)
                    {
                        foreach (var item_ in messageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("MessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (senderMessageIds != null)
                    {
                        foreach (var item_ in senderMessageIds) { urlBuilder_.Append(System.Uri.EscapeDataString("SenderMessageIds")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (receiver_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (receiver_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWFulfillmentDateStart != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWFulfillmentDateStart")).Append('=').Append(System.Uri.EscapeDataString(bDEWFulfillmentDateStart.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bDEWFulfillmentDateEnd != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("BDEWFulfillmentDateEnd")).Append('=').Append(System.Uri.EscapeDataString(bDEWFulfillmentDateEnd.Value.ToString("o", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (state != null)
                    {
                        foreach (var item_ in state) { urlBuilder_.Append(System.Uri.EscapeDataString("State")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetOutboundMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Hinterlegt eine ausgehende Nachricht inkl. Payload für den Versand zu einem Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Nachrichten werden von AS4 Connect asynchron zugestellt.
        /// <br/>Der Status einer Nachricht kann über `GET /outbox` abgefragt werden.
        /// </remarks>
        /// <param name="receiver_Id">Die Id gemäß Codenummerndatenbank.
        /// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]</param>
        /// <param name="payload">Der Payload der Nachricht (Edifact-Datei). Muss immer per gzip komprimiert übertragen werden.</param>
        /// <param name="bDEWDocumentType">Der EDIFACT-Name des Nachrichtentyps gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)</param>
        /// <param name="bDEWDocumentNo">Datenaustauschreferenz (DAR) aus UNB DE0020</param>
        /// <param name="bDEWDocumentDate">Datumstempel bei Erzeugung im Format YYYY-MM-DD.</param>
        /// <param name="messageId">Die Id der ausgehenden Nachricht. Über diese Id wird die Nachricht eindeutig in AS4.Connect identifizierbar.
        /// <br/>Über diese Id wird die &lt;a href="https://developer-campus.de/tracks/architecture/makroarchitektur/resilienz/#idempotenz"&gt;Idempotenz&lt;/a&gt; der Operation gewährleistet.
        /// <br/>Dieser Wert ist nur aufgrund der Kompatibilität optional und wird zukünftig verpflichtend.</param>
        /// <param name="senderMessageId">Optionale Id welcher der Sender für die Nachricht individuell vergeben kann.
        /// <br/>Diese Id sollte aus der zugehörigen Geschäftsapplikation stammen, um kann im weiteren Verlauf dazu benutzt werden die Nachricht in AS4 Connect zu identifizieren.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubmitMessageResponseDto> V1MpMessagesOutboxPostAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, FileParameter payload = null, string? bDEWDocumentType = null, string? bDEWDocumentNo = null, string? bDEWDocumentDate = null, System.Guid? messageId = null, string? senderMessageId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);

                    if (receiver_Id == null)
                        throw new System.ArgumentNullException("receiver_Id");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Id");
                    }

                    if (receiver_Type == null)
                        throw new System.ArgumentNullException("receiver_Type");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture)), "Receiver.Type");
                    }

                    if (payload == null)
                        throw new System.ArgumentNullException("payload");
                    else
                    {
                        var content_payload_ = new System.Net.Http.StreamContent(payload.Data);
                        if (!string.IsNullOrEmpty(payload.ContentType))
                            content_payload_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(payload.ContentType);
                        content_.Add(content_payload_, "Payload", payload.FileName ?? "Payload");
                    }

                    if (bDEWDocumentType == null)
                        throw new System.ArgumentNullException("bDEWDocumentType");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentType, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentType");
                    }

                    if (bDEWDocumentNo == null)
                        throw new System.ArgumentNullException("bDEWDocumentNo");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentNo, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentNo");
                    }

                    if (bDEWDocumentDate == null)
                        throw new System.ArgumentNullException("bDEWDocumentDate");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(bDEWDocumentDate, System.Globalization.CultureInfo.InvariantCulture)), "BDEWDocumentDate");
                    }

                    if (messageId == null)
                        throw new System.ArgumentNullException("messageId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)), "MessageId");
                    }

                    if (senderMessageId == null)
                        throw new System.ArgumentNullException("senderMessageId");
                    else
                    {
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(senderMessageId, System.Globalization.CultureInfo.InvariantCulture)), "SenderMessageId");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/outbox"
                    urlBuilder_.Append("v1/mp/messages/outbox");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubmitMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OutboundMPMessageDto> V1MpMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/outbox/{messageId}"
                    urlBuilder_.Append("v1/mp/messages/outbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OutboundMPMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abfrage des Payloads der ausgehenden Nachricht.
        /// </summary>
        /// <remarks>
        /// Ausgehende Edifact-Dateien können über diesen Endpunkt heruntergeladen werden. Die Datei ist dabei immer
        /// <br/>per gzip komprimiert und muss vom Nutzer der Api noch dekomprimiert werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Der Payload der Nachricht.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> V1MpMessagesOutboxPayloadAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/gzip"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/outbox/{messageId}/payload"
                    urlBuilder_.Append("v1/mp/messages/outbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/payload");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachrichten-Id ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zu viele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt empfangenen Nachrichten für den Wechselprozess ab.
        /// </summary>
        /// <remarks>
        /// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten von fremden Marktteilenhmern bereit.
        /// <br/>            
        /// <br/>Eingehende Nachrichten müssen geeignet über die Geschäftsapplikation verarbeitet werden.
        /// <br/>            
        /// <br/>Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
        /// <br/>            
        /// <br/>### PATH_SWITCH_REQUEST ###
        /// <br/>Ein fremder Marktteilnehmer möchte den Übertragungsweg auf AS4 wechseln.
        /// <br/>            
        /// <br/>Der fremde Marktpartner kommuniziert (bis zu Bestätigung des Wechsels) weiterhin über den bisherige Übertragungsweg.
        /// <br/>Um dem Wechsel auf AS4 zuzustimmen, muss eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` über `/path-switch/messages/outbox`
        /// <br/>an den fremden Marktteilenhmer gesendet werden.
        /// <br/>            
        /// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// <br/>            
        /// <br/>### PATH_SWITCH_CONFIRM ###
        /// <br/>Ein fremder Marktteilnehmer bestätigt den Wechsel auf den AS4-Übertragungsweg.
        /// <br/>            
        /// <br/>Bitte berücksichtigen Sie die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// </remarks>
        /// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryPathSwitchInboxMessagesResponseDto> V1PathSwitchMessagesInboxGetAsync(string? sender_Id = null, PartyIdTypeDto? sender_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/path-switch/messages/inbox"
                    urlBuilder_.Append("v1/path-switch/messages/inbox");
                    urlBuilder_.Append('?');
                    if (sender_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sender_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryPathSwitchInboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Marktteilnehmer ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InboundPathSwitchMessageDto> V1PathSwitchMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/path-switch/messages/inbox/{messageId}"
                    urlBuilder_.Append("v1/path-switch/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InboundPathSwitchMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt gesendetet Nachrichten für den Wechselprozess ab.
        /// </summary>
        /// <remarks>
        /// AS4 Connect stellt hier nur die __letzten__ PATH_SWITCH-Nachrichten die per POST an `/path-switch/messages/outbox`
        /// <br/>gesendet wurden bereit.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand `SUCCESSFUL`.
        /// </remarks>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryPathSwitchOutboxMessagesResponseDto> V1PathSwitchMessagesOutboxGetAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/path-switch/messages/outbox"
                    urlBuilder_.Append("v1/path-switch/messages/outbox");
                    urlBuilder_.Append('?');
                    if (receiver_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (receiver_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryPathSwitchOutboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Marktteilnehmer ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sendet Nachrichten für den Wechselprozess an Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Grundsätzlich werden die Typen `PATH_SWITCH_REQUEST` und `PATH_SWITCH_CONFIRM` wie folgt unterschieden:
        /// <br/>### PATH_SWITCH_REQUEST ###
        /// <br/>Der AS4-Connect Marktpartner möchte den Übertragungsweg auf AS4 ändern und informiert hiermit den fremden
        /// <br/>Marktteilnehmer.
        /// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
        /// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// <br/>Stimmt der fremde Marktteilnehmer dem Wechsel zu, wird er eine Bestätigung vom Typ `PATH_SWITCH_CONFIRM` senden.
        /// <br/>Diese kann der AS4-Connect Marktpartner über `/path-switch/messages/inbox` abrufen.
        /// <br/>### PATH_SWITCH_CONFIRM ###
        /// <br/>Der AS4-Connect Marktpartner möchte eine über `/path-switch/messages/inbox` empfangene Wechselanfrage eines fremden
        /// <br/>Marktteilnehmer bestätígen.
        /// <br/>Bitte berücksichtigen die Vorgaben für den Wechselprozess aus [AWH Einführungsszenario
        /// <br/>AS4](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AWH%20Einf%C3%BChrungsszenario%20AS4.pdf).
        /// </remarks>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SubmitPathSwitchMessageResponseDto> V1PathSwitchMessagesOutboxPostAsync(SubmitPathSwitchMessageRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/path-switch/messages/outbox"
                    urlBuilder_.Append("v1/path-switch/messages/outbox");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SubmitPathSwitchMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Marktteilnehmer ist unbekannt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OutboundPathSwitchMessageDto> V1PathSwitchMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/path-switch/messages/outbox/{messageId}"
                    urlBuilder_.Append("v1/path-switch/messages/outbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OutboundPathSwitchMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gibt Statistiken über die Anzahl der ein- und ausgehenden Nachrichten für einen Marktpartner im letzten und im laufenden Monat zurück.
        /// </summary>
        /// <returns>Die Statistik für den Marktpartner.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StatisticsResponseDto> V1StatisticsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/statistics"
                    urlBuilder_.Append("v1/statistics");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StatisticsResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt empfangenen Test-Nachrichten ab.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich s.g. Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Empfangene Testnachrichten von fremden Marktteilnehmern werden hier bereitgestellt.
        /// <br/>Testnachrichten dienen lediglich zum "Anpingen" von Marktteilnehmern. Der Payload ist hierfür irrelevant und wird
        /// <br/>daher nicht durch AS4 Connect bereitgestellt.
        /// <br/>Details siehe Kapitel 2.3.6 'Testservice' des [BDEW
        /// <br/>AS4-Profil](https://www.bundesnetzagentur.de/DE/Beschlusskammern/1_GZ/BK6-GZ/2021/BK6-21-282/Mitteilung02/AS4%20Profil.pdf)
        /// </remarks>
        /// <param name="sender_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="sender_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryInboxTestMessagesResponseDto> V1TestMessagesInboxGetAsync(string? sender_Id = null, PartyIdTypeDto? sender_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/test/messages/inbox"
                    urlBuilder_.Append("v1/test/messages/inbox");
                    urlBuilder_.Append('?');
                    if (sender_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sender_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Sender.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sender_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryInboxTestMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von eingehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InboundTestMessageDto> V1TestMessagesInboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/test/messages/inbox/{messageId}"
                    urlBuilder_.Append("v1/test/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InboundTestMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt die zuletzt gesendeteten Test-Nachrichten ab.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer feststellen, zu welchem fremden Marktteilenhmer bereits
        /// <br/>Test-Nachrichten gesendet worden sind.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
        /// <br/>`SUCCESSFUL`.
        /// </remarks>
        /// <param name="receiver_Id">Die Marktpartner-Id (MP-ID) gemäß Codenummern-Datenbank (z.B. 9904843000006)</param>
        /// <param name="receiver_Type">Die codevergebene Stelle der MP-ID.</param>
        /// <returns>Die Anfrage wurde erfolgreich verarbeitet.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<QueryTestMessageOutboxMessagesResponseDto> V1TestMessagesOutboxGetAsync(string? receiver_Id = null, PartyIdTypeDto? receiver_Type = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/test/messages/outbox"
                    urlBuilder_.Append("v1/test/messages/outbox");
                    urlBuilder_.Append('?');
                    if (receiver_Id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (receiver_Type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("Receiver.Type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(receiver_Type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<QueryTestMessageOutboxMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sendet Test-Nachrichten an Marktteilnehmer.
        /// </summary>
        /// <remarks>
        /// Bevor ein Wechsel des Übertragungsweg auf AS4 stattfindet (initiiert und bestätigt durch `/path-switch/`)
        /// <br/>sollten erfolreich Testnachrichten zwischen den Marktpartnern ausgetauscht werden.
        /// <br/>Über diesen Aufruf können AS4 Connect Marktteilnehmer Test-Nachrichten an fremden Marktteilenhmer senden.
        /// <br/>AS4 Connect stellt Test-Nachrichten asynchron zu.
        /// <br/>Nachrichten die erfolgreich an einen fremden Marktteilnehmer übertragen wurden, haben den Zustand
        /// <br/>`SUCCESSFUL`.
        /// <br/>Der Zustand kann über GET  `/test/messages/outbox/` abgefragt werden.
        /// </remarks>
        /// <param name="body">Die Empänger der Testnachrichten.</param>
        /// <returns>Erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TestMessageResponseDto> V1TestMessagesOutboxPostAsync(TestMessageRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/test/messages/outbox"
                    urlBuilder_.Append("v1/test/messages/outbox");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TestMessageResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Der Request war fehlerhaft.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Fragt eine Nachrichten von ausgehenden Nachrichten ab inklusive Fehler und Traces.
        /// </summary>
        /// <remarks>
        /// Hier können alle Infos zu einer Nachricht abgefragt werden.
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <returns>Nachricht wurde erfolgreich empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<OutboundTestMessageDto> V1TestMessagesOutboxGetAsync(System.Guid messageId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/test/messages/outbox/{messageId}"
                    urlBuilder_.Append("v1/test/messages/outbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OutboundTestMessageDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht f\u00fcr Id wurde nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Nachricht wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bestätigt den erfolgreichen Erhalt einer Nachricht.
        /// </summary>
        /// <remarks>
        /// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden neuere Nachrichten für die Verarbeitung bereitgestellt.
        /// <br/>            
        /// <br/>Um die Authentizität und Integrität der empfangenen Fahrplan-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
        /// <br/>Der Payload des **JWT** muss den Hashwert der Fahrplan-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
        /// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
        /// <br/>Verschlüsselt wird das Token nicht.
        /// <br/>            
        /// <br/>**Hinweise**:
        /// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
        /// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
        /// <br/>            
        /// <br/>Das Token muss mindestens folgende Claims enthalten:
        /// <br/>```json
        /// <br/>// HEADER:
        /// <br/>{
        /// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
        /// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
        /// <br/>}
        /// <br/>            
        /// <br/>// PAYLOAD:
        /// <br/>{
        /// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
        /// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
        /// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
        /// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen")
        /// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID
        /// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
        /// <br/>}
        /// <br/>            
        /// <br/>// SIGNATURE:
        /// <br/>{
        /// <br/>    ...
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
        /// <returns>Bestätigung wurde akzeptiert.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task V1FpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/inbox/{messageId}/acknowledgement"
                    urlBuilder_.Append("v1/fp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/acknowledgement");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Best\u00e4tigung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
        /// </summary>
        /// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
        /// <returns>Die erneute Zustellung wurde empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RetryMessagesResponseDto> V1FpMessagesOutboxRetriesAsync(RetryMessagesRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/fp/messages/outbox/retries"
                    urlBuilder_.Append("v1/fp/messages/outbox/retries");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RetryMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Die erneute Zustellung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Alle angegebenen Nachrichten wurden nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Bestätigt den erfolgreichen Erhalt einer Nachricht.
        /// </summary>
        /// <remarks>
        /// Erst wenn die bereitgestellten Nachrichten bestätigt wurden, werden über `inbox/messages` neuere Nachrichten für die Verarbeitung bereitgestellt.
        /// <br/>            
        /// <br/>Um die Authentizität und Integrität der empfangenen Edifact-Datei gegenüber AS4 Connect zu bestätigen wird ein **JWT** gemäß [RFC7519](https://www.rfc-editor.org/rfc/rfc7519) genutzt.
        /// <br/>Der Payload des **JWT** muss den Hashwert der Edifact-Datei mittels **SHA256** gemäß [RFC6234](https://www.rfc-editor.org/rfc/rfc6234) beinhalten.
        /// <br/>Die Signierung erfolgt über den privaten Schlüsel des Client-Zertifikats, welches bereits für die Authentifizierung gegenüber AS4 Connect benutzt wird.
        /// <br/>Verschlüsselt wird das Token nicht.
        /// <br/>            
        /// <br/>**Hinweise**:
        /// <br/>Der Hash Wert muss immer auf dem gzip komprimierten Payload berechnet werden.
        /// <br/>Der Algorithmus für die Token-Signierung und -Validierung muss ES384 sein.
        /// <br/>            
        /// <br/>Das Token muss mindestens folgende Claims enthalten:
        /// <br/>```json
        /// <br/>// HEADER:
        /// <br/>{
        /// <br/>   "alg": "ES384", // die verwendete Signatur-Algorithmus (immer ES384), (SECP384R1)
        /// <br/>   "typ": "JWT" // der Typ des Tokens (immer JWT)
        /// <br/>}
        /// <br/>            
        /// <br/>// PAYLOAD:
        /// <br/>{
        /// <br/>   "hash": "07d8d11084e8d500852664c0f64ade1299d418cbe489edefcd422ad698666b33",  // der SHA256 Hashwert des Payloads, als hex-string
        /// <br/>   "cert": "MIICsDCCAjegAwIBAgICEAkwCgYIKoZIzj0EAwMwQTESMBAGA1UEAwwJU00tU3ViLkNBMRIwEAYD…", // Base64-Darstellung des DER-kodierten Client-Zertifikats, welches zur Erstellung der Signatur verwendet wurde
        /// <br/>   "iss": "9904843000000@BDEW", // der Aussteller des Tokens (Party-ID des Absenders, "MP-ID"@"Typ", analog zum "OU"-Feld im Zertifikat)
        /// <br/>   "aud": "schleupen", // der Empfänger des Tokens (immer "schleupen")
        /// <br/>   "mid": "f613cfa2-a7a2-446f-8599-ce2c9525bbb1", // die Message-ID
        /// <br/>   "iat": 1516239022 // Zeitpunkt der Erstellung des Tokens
        /// <br/>}
        /// <br/>            
        /// <br/>// SIGNATURE:
        /// <br/>{
        /// <br/>    ...
        /// <br/>}
        /// <br/>```
        /// </remarks>
        /// <param name="messageId">Die Id der Nachricht.</param>
        /// <param name="body">Die für die Bestätigung notwendigen Daten.</param>
        /// <returns>Bestätigung wurde akzeptiert.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task V1MpMessagesInboxAcknowledgementAsync(System.Guid messageId, MessageAcknowledgedRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (messageId == null)
                throw new System.ArgumentNullException("messageId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/inbox/{messageId}/acknowledgement"
                    urlBuilder_.Append("v1/mp/messages/inbox/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(messageId, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/acknowledgement");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Best\u00e4tigung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stößt die erneute Verarbeitung von fehlgeschlagenen Nachrichten an.
        /// </summary>
        /// <param name="body">Die Ids der erneut zuzustellenden Nachrichten.</param>
        /// <returns>Die erneute Zustellung wurde empfangen.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RetryMessagesResponseDto> V1MpMessagesOutboxRetriesAsync(RetryMessagesRequestDto? body = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value);
                    var content_ = new System.Net.Http.StringContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "v1/mp/messages/outbox/retries"
                    urlBuilder_.Append("v1/mp/messages/outbox/retries");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RetryMessagesResponseDto>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Die erneute Zustellung wurde abgelehnt.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Alle angegebenen Nachrichten wurden nicht gefunden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Es wurden zuviele Requests empfangen.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T)!, string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody!, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody!, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object? value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Weiterführende Informationen über die Edifact-Syntax-Prüfung.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record EdifactSyntaxCheckDto : System.ComponentModel.INotifyPropertyChanged
    {
        private EdifactSyntaxCheckStatusDto _status = default!;
        private System.Guid? _outboundMessageReferenceId = default!;

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public EdifactSyntaxCheckStatusDto Status
        {
            get { return _status; }

            set
            {
                if (_status != value)
                {
                    _status = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Message ID der ausgehende CONTRL, falls eine CONTRL aufgrund Syntaxfehler in der eingehenden Nachricht versendet wurde.
        /// <br/>Ist null, falls die eingehende Nachrichten keine Syntaxfehler hatte.
        /// <br/>Ist null, falls keine CONTRL Nachricht versendet werden konnte (z. B. grundlegend falsche Daten im Payload).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundMessageReferenceId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OutboundMessageReferenceId
        {
            get { return _outboundMessageReferenceId; }

            set
            {
                if (_outboundMessageReferenceId != value)
                {
                    _outboundMessageReferenceId = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Informationen über den Zustand der Syntax.
    /// <br/>UNKNOWN: Syntax wurde nicht geprüft.
    /// <br/>VALID_SYNTAX: Syntax ist valide.
    /// <br/>INVALID_SYNTAX: Syntax ist invalide.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EdifactSyntaxCheckStatusDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"VALID_SYNTAX")]
        VALID_SYNTAX = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_SYNTAX")]
        INVALID_SYNTAX = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record ErrorDto : System.ComponentModel.INotifyPropertyChanged
    {
        private string? _title = default!;
        private string? _detail = default!;
        private System.DateTimeOffset _timestamp = default!;
        private ErrorTypeDto _errorType = default!;
        private ResponsiblePartyDto _responsibleParty = default!;

        /// <summary>
        /// Grundlegende Informationen über den Fehler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Title
        {
            get { return _title; }

            set
            {
                if (_title != value)
                {
                    _title = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Eine detaillierte Beschreibung des Fehlers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Detail
        {
            get { return _detail; }

            set
            {
                if (_detail != value)
                {
                    _detail = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Fehlers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Timestamp
        {
            get { return _timestamp; }

            set
            {
                if (_timestamp != value)
                {
                    _timestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("errorType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ErrorTypeDto ErrorType
        {
            get { return _errorType; }

            set
            {
                if (_errorType != value)
                {
                    _errorType = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("responsibleParty", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ResponsiblePartyDto ResponsibleParty
        {
            get { return _responsibleParty; }

            set
            {
                if (_responsibleParty != value)
                {
                    _responsibleParty = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ErrorTypeDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNDEFINED")]
        UNDEFINED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TRANSPORT")]
        TRANSPORT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SECURITY")]
        SECURITY = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PROTOCOL")]
        PROTOCOL = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record FPMessageQueryResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundFPMessageDto>? _inboundFpMessages = default!;
        private System.Collections.Generic.ICollection<OutboundFPMessageDto>? _outboundFpMessages = default!;

        [Newtonsoft.Json.JsonProperty("inboundFpMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundFPMessageDto>? InboundFpMessages
        {
            get { return _inboundFpMessages; }

            set
            {
                if (_inboundFpMessages != value)
                {
                    _inboundFpMessages = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("outboundFpMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundFPMessageDto>? OutboundFpMessages
        {
            get { return _outboundFpMessages; }

            set
            {
                if (_outboundFpMessages != value)
                {
                    _outboundFpMessages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record GetOutboundFPMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundFPMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundFPMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record GetOutboundMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundMPMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMPMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record InboundFPMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private PayloadDto _payload = default!;
        private InboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private string? _bdewDocumentNo = default!;
        private string? _bdewDocumentType = default!;
        private string? _bdewFulfillmentDate = default!;
        private string? _bdewSubjectPartyId = default!;
        private string? _bdewSubjectPartyRole = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PayloadDto Payload
        {
            get { return _payload; }

            set
            {
                if (_payload != value)
                {
                    _payload = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentNo
        {
            get { return _bdewDocumentNo; }

            set
            {
                if (_bdewDocumentNo != value)
                {
                    _bdewDocumentNo = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentType
        {
            get { return _bdewDocumentType; }

            set
            {
                if (_bdewDocumentType != value)
                {
                    _bdewDocumentType = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewFulfillmentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewFulfillmentDate
        {
            get { return _bdewFulfillmentDate; }

            set
            {
                if (_bdewFulfillmentDate != value)
                {
                    _bdewFulfillmentDate = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewSubjectPartyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewSubjectPartyId
        {
            get { return _bdewSubjectPartyId; }

            set
            {
                if (_bdewSubjectPartyId != value)
                {
                    _bdewSubjectPartyId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewSubjectPartyRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewSubjectPartyRole
        {
            get { return _bdewSubjectPartyRole; }

            set
            {
                if (_bdewSubjectPartyRole != value)
                {
                    _bdewSubjectPartyRole = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record InboundMPMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private PayloadDto _payload = default!;
        private InboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private string? _bdewDocumentNo = default!;
        private string? _bdewDocType = default!;
        private string? _bdewDocumentDate = default!;
        private ErrorDto _error = default!;
        private EdifactSyntaxCheckDto _edifactSyntaxCheck = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PayloadDto Payload
        {
            get { return _payload; }

            set
            {
                if (_payload != value)
                {
                    _payload = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Datenaustauschreferenz (DAR).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentNo
        {
            get { return _bdewDocumentNo; }

            set
            {
                if (_bdewDocumentNo != value)
                {
                    _bdewDocumentNo = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocType
        {
            get { return _bdewDocType; }

            set
            {
                if (_bdewDocType != value)
                {
                    _bdewDocType = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Datumstempel bei Erzeugung im Format YYYY-MM-DD.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentDate
        {
            get { return _bdewDocumentDate; }

            set
            {
                if (_bdewDocumentDate != value)
                {
                    _bdewDocumentDate = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("edifactSyntaxCheck", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EdifactSyntaxCheckDto EdifactSyntaxCheck
        {
            get { return _edifactSyntaxCheck; }

            set
            {
                if (_edifactSyntaxCheck != value)
                {
                    _edifactSyntaxCheck = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Mögliche Status einer eingehenden Nachricht.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InboundMessageStateDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PROVIDED")]
        PROVIDED = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DELIVERED")]
        DELIVERED = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ACKNOWLEDGED")]
        ACKNOWLEDGED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record InboundMessageStateDtoMessageTraceEntryDto : System.ComponentModel.INotifyPropertyChanged
    {
        private InboundMessageStateDto _state = default!;
        private System.DateTimeOffset _timestamp = default!;
        private string? _message = default!;

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Zeitstempel der Aktion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Timestamp
        {
            get { return _timestamp; }

            set
            {
                if (_timestamp != value)
                {
                    _timestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Eine optionale Nachricht.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Message
        {
            get { return _message; }

            set
            {
                if (_message != value)
                {
                    _message = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record InboundPathSwitchMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private InboundMessageStateDto _state = default!;
        private PathSwitchMessageType _messageType = default!;
        private System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PathSwitchMessageType MessageType
        {
            get { return _messageType; }

            set
            {
                if (_messageType != value)
                {
                    _messageType = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record InboundTestMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private InboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record MessageAcknowledgedRequestDto : System.ComponentModel.INotifyPropertyChanged
    {
        private string _jwt = default!;

        /// <summary>
        /// Signiertes Json Web Token welches den Hash des empfangenen Payloads beinhaltet.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("jwt", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string Jwt
        {
            get { return _jwt; }

            set
            {
                if (_jwt != value)
                {
                    _jwt = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum MessageDirectionDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"INBOUND")]
        INBOUND = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"OUTBOUND")]
        OUTBOUND = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record MessageQueryResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundMPMessageDto>? _inboundMessages = default!;
        private System.Collections.Generic.ICollection<OutboundMPMessageDto>? _outboundMessages = default!;

        [Newtonsoft.Json.JsonProperty("inboundMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMPMessageDto>? InboundMessages
        {
            get { return _inboundMessages; }

            set
            {
                if (_inboundMessages != value)
                {
                    _inboundMessages = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("outboundMessages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMPMessageDto>? OutboundMessages
        {
            get { return _outboundMessages; }

            set
            {
                if (_outboundMessages != value)
                {
                    _outboundMessages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record OutboundFPMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private PayloadDto _payload = default!;
        private string? _senderMessageId = default!;
        private OutboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private string? _bdewDocumentNo = default!;
        private string? _bdewDocumentType = default!;
        private string? _bdewFulfillmentDate = default!;
        private string? _bdewSubjectPartyId = default!;
        private string? _bdewSubjectPartyRole = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PayloadDto Payload
        {
            get { return _payload; }

            set
            {
                if (_payload != value)
                {
                    _payload = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Id der Nachricht die der Sender beim übermitteln der Nachricht vergeben hat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("senderMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? SenderMessageId
        {
            get { return _senderMessageId; }

            set
            {
                if (_senderMessageId != value)
                {
                    _senderMessageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Version der Nachricht. ( z.B. Confirmed Message Version für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentNo
        {
            get { return _bdewDocumentNo; }

            set
            {
                if (_bdewDocumentNo != value)
                {
                    _bdewDocumentNo = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Typ der Nachricht. ( A01 für Schedule. A17 für Acknowledge. A16 für AnomalyReport. A07, A08 oder A09 für ConfirmationReport )
        /// <br/>Siehe: Regelungen zum sicheren Austausch im Fahrplanprozess 2.1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentType
        {
            get { return _bdewDocumentType; }

            set
            {
                if (_bdewDocumentType != value)
                {
                    _bdewDocumentType = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Das Datum des Fahrplantages im Format 'yyyy-MM-dd'.
        /// <br/>Siehe: FAQ zur Einführung von AS4 im Fahrplanaustausch
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewFulfillmentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewFulfillmentDate
        {
            get { return _bdewFulfillmentDate; }

            set
            {
                if (_bdewFulfillmentDate != value)
                {
                    _bdewFulfillmentDate = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Eine Senderidentifikation gemäß Coding Scheme, z. B. A01.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewSubjectPartyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewSubjectPartyId
        {
            get { return _bdewSubjectPartyId; }

            set
            {
                if (_bdewSubjectPartyId != value)
                {
                    _bdewSubjectPartyId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Ein Code für die Senderrole, z. B. A08 (für Schedule) oder A04 (für Acknowledge, ConfirmationReport oder AnomalyReport).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewSubjectPartyRole", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewSubjectPartyRole
        {
            get { return _bdewSubjectPartyRole; }

            set
            {
                if (_bdewSubjectPartyRole != value)
                {
                    _bdewSubjectPartyRole = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record OutboundMPMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private PayloadDto _payload = default!;
        private string? _senderMessageId = default!;
        private OutboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private string? _bdewDocumentNo = default!;
        private string? _bdewDocType = default!;
        private string? _bdewDocumentDate = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PayloadDto Payload
        {
            get { return _payload; }

            set
            {
                if (_payload != value)
                {
                    _payload = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Id der Nachricht die der Sender beim übermitteln der Nachricht vergeben hat.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("senderMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? SenderMessageId
        {
            get { return _senderMessageId; }

            set
            {
                if (_senderMessageId != value)
                {
                    _senderMessageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Die Datenaustauschreferenz (DAR).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentNo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentNo
        {
            get { return _bdewDocumentNo; }

            set
            {
                if (_bdewDocumentNo != value)
                {
                    _bdewDocumentNo = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Nachrichtentyp gem. UNH DE0065 (z.B. CONTRL, UTILMD ...)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocType
        {
            get { return _bdewDocType; }

            set
            {
                if (_bdewDocType != value)
                {
                    _bdewDocType = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Datumstempel bei Erzeugung im Format YYYY-MM-DD.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bdewDocumentDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? BdewDocumentDate
        {
            get { return _bdewDocumentDate; }

            set
            {
                if (_bdewDocumentDate != value)
                {
                    _bdewDocumentDate = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Mögliche Status einer eingehenden Nachricht.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutboundMessageStateDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IN_PROGRESS")]
        IN_PROGRESS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESSFUL")]
        SUCCESSFUL = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record OutboundMessageStateDtoMessageTraceEntryDto : System.ComponentModel.INotifyPropertyChanged
    {
        private OutboundMessageStateDto _state = default!;
        private System.DateTimeOffset _timestamp = default!;
        private string? _message = default!;

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Zeitstempel der Aktion.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Timestamp
        {
            get { return _timestamp; }

            set
            {
                if (_timestamp != value)
                {
                    _timestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Eine optionale Nachricht.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Message
        {
            get { return _message; }

            set
            {
                if (_message != value)
                {
                    _message = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record OutboundPathSwitchMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private OutboundMessageStateDto _state = default!;
        private PathSwitchMessageType _messageType = default!;
        private System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PathSwitchMessageType MessageType
        {
            get { return _messageType; }

            set
            {
                if (_messageType != value)
                {
                    _messageType = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record OutboundTestMessageDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private System.DateTimeOffset _created_at = default!;
        private System.DateTimeOffset? _receiptTimestamp = default!;
        private PartyInfoDto _partyInfo = new PartyInfoDto();
        private OutboundMessageStateDto _state = default!;
        private System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? _trace = default!;
        private ErrorDto _error = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel der Generierung in AS4 Connect.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created_at", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Created_at
        {
            get { return _created_at; }

            set
            {
                if (_created_at != value)
                {
                    _created_at = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der Zeitstempel des Receipts, das für diese Nachricht ausgestellt wurde, falls vorhanden.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiptTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ReceiptTimestamp
        {
            get { return _receiptTimestamp; }

            set
            {
                if (_receiptTimestamp != value)
                {
                    _receiptTimestamp = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("partyInfo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PartyInfoDto PartyInfo
        {
            get { return _partyInfo; }

            set
            {
                if (_partyInfo != value)
                {
                    _partyInfo = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OutboundMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("trace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundMessageStateDtoMessageTraceEntryDto>? Trace
        {
            get { return _trace; }

            set
            {
                if (_trace != value)
                {
                    _trace = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorDto Error
        {
            get { return _error; }

            set
            {
                if (_error != value)
                {
                    _error = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Die codevergebene Stelle der MP-ID.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PartyIdTypeDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"BDEW")]
        BDEW = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DVGW")]
        DVGW = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"GS1")]
        GS1 = 2,

    }

    /// <summary>
    /// Der Identifier eines Marktteilnehmer.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record PartyIdentifierDto : System.ComponentModel.INotifyPropertyChanged
    {
        private string _id = default!;
        private PartyIdTypeDto _type = default!;

        /// <summary>
        /// Die Id gemäß Codenummerndatenbank.
        /// <br/>[OASIS ebXML Messaging Services Version: 'eb:UserMessage/eb:PartyInfo/From|To/PartyId/'/]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string Id
        {
            get { return _id; }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PartyIdTypeDto Type
        {
            get { return _type; }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record PartyInfoDto : System.ComponentModel.INotifyPropertyChanged
    {
        private PartyIdentifierDto _sender = default!;
        private PartyIdentifierDto _receiver = default!;

        [Newtonsoft.Json.JsonProperty("sender", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PartyIdentifierDto Sender
        {
            get { return _sender; }

            set
            {
                if (_sender != value)
                {
                    _sender = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("receiver", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PartyIdentifierDto Receiver
        {
            get { return _receiver; }

            set
            {
                if (_receiver != value)
                {
                    _receiver = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PathSwitchMessageType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"PATH_SWITCH_REQUEST")]
        PATH_SWITCH_REQUEST = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PATH_SWITCH_CONFIRM")]
        PATH_SWITCH_CONFIRM = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record PayloadDto : System.ComponentModel.INotifyPropertyChanged
    {
        private long _sizeInBytes = default!;
        private string _hashSHA256 = default!;

        /// <summary>
        /// Die Größe des komprimierten Payloads in Bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sizeInBytes", Required = Newtonsoft.Json.Required.Always)]
        public long SizeInBytes
        {
            get { return _sizeInBytes; }

            set
            {
                if (_sizeInBytes != value)
                {
                    _sizeInBytes = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Der SHA256 Hash (base64 encoded) des komprimierten Payloads.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hashSHA256", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public string HashSHA256
        {
            get { return _hashSHA256; }

            set
            {
                if (_hashSHA256 != value)
                {
                    _hashSHA256 = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record ProblemDetails : System.ComponentModel.INotifyPropertyChanged
    {
        private string? _type = default!;
        private string? _title = default!;
        private int? _status = default!;
        private string? _detail = default!;
        private string? _instance = default!;

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Type
        {
            get { return _type; }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("title", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Title
        {
            get { return _title; }

            set
            {
                if (_title != value)
                {
                    _title = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Status
        {
            get { return _status; }

            set
            {
                if (_status != value)
                {
                    _status = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Detail
        {
            get { return _detail; }

            set
            {
                if (_detail != value)
                {
                    _detail = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("instance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string? Instance
        {
            get { return _instance; }

            set
            {
                if (_instance != value)
                {
                    _instance = value;
                    RaisePropertyChanged();
                }
            }
        }

        private System.Collections.Generic.IDictionary<string, object>? _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryInboxFPMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundFPMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundFPMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryInboxMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundMPMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundMPMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryInboxTestMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundTestMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundTestMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryPathSwitchInboxMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<InboundPathSwitchMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InboundPathSwitchMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryPathSwitchOutboxMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record QueryTestMessageOutboxMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundTestMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundTestMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ResponsiblePartyDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNDEFINED")]
        UNDEFINED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AS4_CONNECT")]
        AS4_CONNECT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"FOREIGN_MARKETPARTNER")]
        FOREIGN_MARKETPARTNER = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"CUSTOMER")]
        CUSTOMER = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record RetryMessageRequestDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record RetryMessageResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Guid _messageId = default!;
        private RetryMessageStateDto _state = default!;
        private int? _count = default!;

        /// <summary>
        /// Die Id der Nachricht
        /// </summary>
        [Newtonsoft.Json.JsonProperty("messageId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid MessageId
        {
            get { return _messageId; }

            set
            {
                if (_messageId != value)
                {
                    _messageId = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RetryMessageStateDto State
        {
            get { return _state; }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Anzahl der durchgeführten erneuten Zustellungen
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Count
        {
            get { return _count; }

            set
            {
                if (_count != value)
                {
                    _count = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Mögliche Status einer eingehenden Nachricht.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum RetryMessageStateDto
    {

        [System.Runtime.Serialization.EnumMember(Value = @"RETRY_ACCEPTED")]
        RETRY_ACCEPTED = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RETRY_MESSAGE_ALREADY_SUCCESSFUL")]
        RETRY_MESSAGE_ALREADY_SUCCESSFUL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RETRY_MESSAGE_NOT_FOUND")]
        RETRY_MESSAGE_NOT_FOUND = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"RETRY_LIMIT_REACHED")]
        RETRY_LIMIT_REACHED = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"RETRY_OTHER_ERROR")]
        RETRY_OTHER_ERROR = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record RetryMessagesRequestDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<RetryMessageRequestDto> _retries = new System.Collections.ObjectModel.Collection<RetryMessageRequestDto>();

        /// <summary>
        /// Erneut zu versendende Nachrichten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RetryMessageRequestDto> Retries
        {
            get { return _retries; }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record RetryMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<RetryMessageResponseDto>? _retries = default!;

        /// <summary>
        /// Erneut zu versendende Nachrichten
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RetryMessageResponseDto>? Retries
        {
            get { return _retries; }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record StatisticMessagesResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private int _lastMonthCount = default!;
        private int _currentMonthCount = default!;

        /// <summary>
        /// Anzahl Nachrichten des letzten Kalender Monats
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastMonthCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int LastMonthCount
        {
            get { return _lastMonthCount; }

            set
            {
                if (_lastMonthCount != value)
                {
                    _lastMonthCount = value;
                    RaisePropertyChanged();
                }
            }
        }

        /// <summary>
        /// Anzahl Nachrichten des aktuellen Kalender Monats
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currentMonthCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int CurrentMonthCount
        {
            get { return _currentMonthCount; }

            set
            {
                if (_currentMonthCount != value)
                {
                    _currentMonthCount = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record StatisticsResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private StatisticMessagesResponseDto _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatisticMessagesResponseDto Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record SubmitFPMessageResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private OutboundFPMessageDto _outboundFPMessage = default!;

        [Newtonsoft.Json.JsonProperty("outboundFPMessage", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OutboundFPMessageDto OutboundFPMessage
        {
            get { return _outboundFPMessage; }

            set
            {
                if (_outboundFPMessage != value)
                {
                    _outboundFPMessage = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record SubmitMessageResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private OutboundMPMessageDto _message = default!;

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OutboundMPMessageDto Message
        {
            get { return _message; }

            set
            {
                if (_message != value)
                {
                    _message = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record SubmitPathSwitchMessageRequestDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<PartyIdentifierDto> _receivers = new System.Collections.ObjectModel.Collection<PartyIdentifierDto>();
        private PathSwitchMessageType _messageType = default!;

        /// <summary>
        /// Die Empfänger an die eine Path-Switch Message gesendet werden soll.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receivers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PartyIdentifierDto> Receivers
        {
            get { return _receivers; }

            set
            {
                if (_receivers != value)
                {
                    _receivers = value;
                    RaisePropertyChanged();
                }
            }
        }

        [Newtonsoft.Json.JsonProperty("messageType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PathSwitchMessageType MessageType
        {
            get { return _messageType; }

            set
            {
                if (_messageType != value)
                {
                    _messageType = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record SubmitPathSwitchMessageResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundPathSwitchMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record TestMessageRequestDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<PartyIdentifierDto> _receivers = new System.Collections.ObjectModel.Collection<PartyIdentifierDto>();

        /// <summary>
        /// Die Empfänger an die eine Test-Nachricht gesendet werden soll.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receivers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<PartyIdentifierDto> Receivers
        {
            get { return _receivers; }

            set
            {
                if (_receivers != value)
                {
                    _receivers = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial record TestMessageResponseDto : System.ComponentModel.INotifyPropertyChanged
    {
        private System.Collections.Generic.ICollection<OutboundTestMessageDto>? _messages = default!;

        [Newtonsoft.Json.JsonProperty("messages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OutboundTestMessageDto>? Messages
        {
            get { return _messages; }

            set
            {
                if (_messages != value)
                {
                    _messages = value;
                    RaisePropertyChanged();
                }
            }
        }

        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        protected virtual void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string? propertyName = null)
        {
            var handler = PropertyChanged;
            if (handler != null)
                handler(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string? fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string? fileName, string? contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string? FileName { get; private set; }

        public string? ContentType { get; private set; }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable? _client;
        private System.IDisposable? _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable? client, System.IDisposable? response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string? Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string? response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception? innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string? response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception? innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625